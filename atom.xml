<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[JNing+]]></title>
  <subtitle><![CDATA[Stay hungry, Stay foolish...]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="https://ningban.github.io/"/>
  <updated>2015-03-24T13:19:07.000Z</updated>
  <id>https://ningban.github.io/</id>
  
  <author>
    <name><![CDATA[JNing]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[朴素贝叶斯分类器]]></title>
    <link href="https://ningban.github.io/2015/03/23/Naive-Bayes-classifier/"/>
    <id>https://ningban.github.io/2015/03/23/Naive-Bayes-classifier/</id>
    <published>2015-03-23T12:26:56.000Z</published>
    <updated>2015-03-24T13:19:07.000Z</updated>
    <content type="html"><![CDATA[<h1 id="朴素贝叶斯引论">朴素贝叶斯引论</h1><p>　　对于分类而言，使用概率有时要比使用硬规则更为有效。贝叶斯概率及贝叶斯准则提供了一种利用已知值来估计未知概率的有效方法。<br>　　可以通过特征之间的条件独立性假设，降低对数据量的需求。独立性假设是指一个词的出现概率并不依赖于文档中的其他词。当然我们也知道这个假设过于简单。这就是<code>之所以称为朴素贝叶斯的原因</code>。尽管条件独立性假设不正确，但是朴素贝叶斯仍然是一种有效的分类器。</p>
<h1 id="使用条件概率来分类">使用条件概率来分类</h1><p>　　贝叶斯决策理论要求计算两个概率<img style="padding-top:0px;" src="http://chart.apis.google.com/chart?cht=tx&chl=p_1(x, y)">和<img style="padding-top:0px;" src="http://chart.apis.google.com/chart?cht=tx&chl=p_2(x, y)">：<br>　　1. 如果<img style="padding-top:0px;" src="http://chart.apis.google.com/chart?cht=tx&chl=p_1(x, y) > p_2(x, y)">，那么属于类别1；<br>　　2. 如果<img style="padding-top:0px;" src="http://chart.apis.google.com/chart?cht=tx&chl=p_2(x, y) > p_1(x, y)">，那么属于类别2。<br>　　但这两个准则并不是贝叶斯决策理论的所有内容。使用<img style="padding-top:0px;" src="http://chart.apis.google.com/chart?cht=tx&chl=p_1(x, y) ">和<img style="padding-top:0px;" src="http://chart.apis.google.com/chart?cht=tx&chl=p_2(x, y)">只是为了尽可能简化描述，而真正需要计算和比较的是<img style="padding-top:0px;" src="http://chart.apis.google.com/chart?cht=tx&chl=p(c_1|x, y)">和<img style="padding-top:0px;" src="http://chart.apis.google.com/chart?cht=tx&chl=p(c_2|x, y)">。这些符号代表的具体意义是：给定某个由(x, y)表示的数据点，那么该数据点来自类别<img style="padding-top:0px;" src="http://chart.apis.google.com/chart?cht=tx&chl=c_1">的概率是多少？数据点来自类别<img style="padding-top:0px;" src="http://chart.apis.google.com/chart?cht=tx&chl=c_2">的概率又是多少？注意这些概率与概率<img style="padding-top:0px;" src="http://chart.apis.google.com/chart?cht=tx&chl=p(x, y|c_1)">并不一样，不过可以使用贝叶斯准则来交换概率条件与结果。具体地，应用贝叶斯准则得到：<br><img src="http://chart.apis.google.com/chart?cht=tx&chl= p(c_i|x, y) = \frac{p(x, y|c_i)p(c_i)}{p(x, y)}\qquad" style=" clear: both;display: block;margin:auto;"><br>　　使用这些定义，可以定义贝叶斯分类准则为：<br>　　1. 如果<img style="padding-top:0px;" src="http://chart.apis.google.com/chart?cht=tx&chl=p(c_1|x, y) > p(c_2|x, y)">，那么属于类别<img style="padding-top:0px;" src="http://chart.apis.google.com/chart?cht=tx&chl=c_1">；<br>　　2. 如果<img style="padding-top:0px;" src="http://chart.apis.google.com/chart?cht=tx&chl=p(c_1|x, y) < p(c_2|x, y)">，那么属于类别<img style="padding-top:0px;" src="http://chart.apis.google.com/chart?cht=tx&chl=c_2">。<br>　　使用贝叶斯准则，可以通过已知的三个概率值来计算未知的概率值。后面就会给出利用贝叶斯准则来计算概率并对数据进行分类的代码。</p>
<h1 id="使用朴素贝叶斯进行文档分类">使用朴素贝叶斯进行文档分类</h1><p>　　机器学习的一个重要应用就是文档的自动分类。在文档分类中，整个文档（如一封电子邮件）是实例，而电子邮件中的某些元素则构成特征。虽然电子邮件是一种会不断增加的文本，但我们同样也可以对新闻报道/用户留言/政府公文等其他任意类型的文本进行分类。我们可以观察文档中出现的词，并把没每个词的出现或者不出现作为一个特征，这样得到的特征数目就会跟词汇表中的词目一样多。朴素贝叶斯是贝叶斯分类器的一个扩展，是用于文档分类的常用算法。</p>
<h2 id="朴素贝叶斯的一般过程">朴素贝叶斯的一般过程</h2><p>　　1. 收集数据：可以使用任何方法；<br>　　2. 准备数据：需要数值型或者布尔型数据；<br>　　3. 分析数据：有大量特征时，绘制特征作用不大，此时使用直方图效果更好；<br>　　4. 训练算法：计算不同的独立特征的条件概率；<br>　　5. 测试算法：计算错误率；<br>　　6. 使用算法：一个常见的朴素贝叶斯应用是文档分类。可以在任意的分类场景中使用朴素贝叶斯分类器，不一定非要是文本。</p>
<h2 id="准备数据：从文本中构建词向量">准备数据：从文本中构建词向量</h2><p>　　我们将把文本看成单词向量或者词条向量，也就是说将句子转换为向量。考虑出现在所有文档中的所有单词，再决定将哪些词纳入词汇表或者说所要的词汇集合，然后必须要将每一篇文档转换为词汇表上的向量。</p>
<h2 id="训练算法：从词向量计算概率">训练算法：从词向量计算概率</h2><p>　　上面介绍了如何将一组单词转换为一组数字，接下来看看如何使用这些数字计算概率。现在已经知道一个词是否出现在一篇文档中，也知道该文档所属的类别。我们重写贝叶斯规则，将之前的x，y替换为w。w表示这是一个向量，即它由多个数值组成。<br><img src="http://chart.apis.google.com/chart?cht=tx&chl=p(c_i|w) = \frac{p(w|c_i)p(c_i)}{p(w)}" style=" clear: both;display: block;margin:auto;"><br>　　我们将使用上述公式，对每个类计算该值，然后比较这两个概率值的大小。如何计算呢？首先可以通过类别i（侮辱性留言或非侮辱性留言）中文档数除以总的文档数来计算概率<img style="padding-top:0px;" src="http://chart.apis.google.com/chart?cht=tx&chl=p(c_i)">。接下来计算<img style="padding-top:0px;" src="http://chart.apis.google.com/chart?cht=tx&chl=p(w|c_i)">，这里就要用到朴素贝叶斯假设。如果将w展开为一个个独立特征，那么就可以将上述概率写作<img style="padding-top:0px;" src="http://chart.apis.google.com/chart?cht=tx&chl=p(w_0, w_1, w_2, ..., w_n|c_i)">。这里假设所有词都相互独立，该假设也称作条件独立性假设，它意味着可以使用<img style="padding-top:0px;" src="http://chart.apis.google.com/chart?cht=tx&chl=p(w_0|c_i)p(w_1|c_i)p(w_2|c_i)...p(w_n|c_i)">来计算上述概率，这就极大地简化了计算过程。</p>
<h2 id="测试算法：根据现实情况修改分类器">测试算法：根据现实情况修改分类器</h2><p>　　第一个问题：利用贝叶斯分类器对文档进行分类时，要计算多个概率的乘积以获得文档属于某个类别的概率，即计算<img style="padding-top:0px;" src="http://chart.apis.google.com/chart?cht=tx&chl=p(w_0|c_1)p(w_1|c_1)p(w_2|c_1)..">。如果其中一个概率值为0，那么最后的乘积也为0。为了降低这种影响，可以将所有词的出现数初始化为1，并将分母初始化为2。<br>　　第二个问题：下溢出，这是由于太多很小的数相乘造成的。当计算乘积<img style="padding-top:0px;" src="http://chart.apis.google.com/chart?cht=tx&chl=p(w_0|c_1)p(w_1|c_1)p(w_2|c_1)..."> 时，由于大部分因子都非常小，所以程序会下溢出或者得到不正确的答案。一种解决办法是对乘积取自然对数。在代数中有ln(a*b) = ln(a) + ln(b)，于是通过求对数可以避免下溢出或者浮点数导致的错误。</p>
<h2 id="文档词袋模型">文档词袋模型</h2><p>　　到目前未知，我们将每个词的出现与否作为一个特征，这可以被描述为<code>词集模型</code>(set-of-words model)。如果一个词在文档中出现不止一次，这可能意味着包含该词是否出现在文档中所不能表达的某种信息，这种方法被称为<code>词袋模型</code>(bags-of-words model)。在词袋中，每个单词可以出现多次，而在词集中，每个词只能出现一次。为了适应词袋模型，每当遇到一个单词时，它会增加词向量中的对应值，而不只是将对应的数值设为1。<br>　　另外，词汇表中的一小部分单词却占据了所有文本用词的大部分。产生这种现象的原因是因为语言中大部分都是冗余和结构辅助性内容。一个常用的方法是<code>移除高频词</code>，另一个常用的方法是不仅移除高频词，同时从某个预定词表中移除结构上的辅助词。该词表称为<code>停用词表</code>（stop word list），当然也可以花大量时间对切分器进行优化。</p>
<h2 id="python代码">python代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#-*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="comment">#FileName:bayes.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：初始化数据集，即文档矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataSet</span><span class="params">()</span>:</span></span><br><span class="line">  postingList = [[<span class="string">'my'</span>, <span class="string">'dog'</span>, <span class="string">'has'</span>, <span class="string">'flea'</span>, <span class="string">'problems'</span>, <span class="string">'help'</span>, <span class="string">'please'</span> ],</span><br><span class="line">  		[<span class="string">'maybe'</span>, <span class="string">'not'</span>, <span class="string">'take'</span>, <span class="string">'him'</span>,<span class="string">'to'</span>, <span class="string">'dog'</span>,<span class="string">'park'</span>, <span class="string">'stupid'</span>],</span><br><span class="line">  		[<span class="string">'my'</span>, <span class="string">'dalmation'</span>, <span class="string">'is'</span>, <span class="string">'so'</span>, <span class="string">'cute'</span>, <span class="string">'I'</span>, <span class="string">'love'</span>, <span class="string">'him'</span>],</span><br><span class="line">  		[<span class="string">'stop'</span>, <span class="string">'posting'</span>, <span class="string">'stupid'</span>, <span class="string">'worthless'</span>, <span class="string">'garbage'</span>],</span><br><span class="line">  		[<span class="string">'mr'</span>, <span class="string">'licks'</span>, <span class="string">'ate'</span>, <span class="string">'my'</span>, <span class="string">'steak'</span>, <span class="string">'how'</span>, <span class="string">'to'</span>, <span class="string">'stop'</span>, <span class="string">'him'</span>],</span><br><span class="line">  		[<span class="string">'quit'</span>, <span class="string">'buying'</span>, <span class="string">'worthless'</span>, <span class="string">'dog'</span>, <span class="string">'food'</span>, <span class="string">'stupid'</span>]]</span><br><span class="line">  classVec = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>] <span class="comment">#1代表侮辱性文字,0代表正常言论</span></span><br><span class="line">  <span class="keyword">return</span> postingList, classVec</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：初始化词表</span></span><br><span class="line"><span class="comment">#param：</span></span><br><span class="line"><span class="comment">#	dataSet ==&gt; 数据集，即文档矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createVocabList</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">  vocabSet = set([])</span><br><span class="line">  <span class="keyword">for</span> document <span class="keyword">in</span> dataSet:</span><br><span class="line">  	vocabSet = vocabSet | set(document) <span class="comment">#取并集</span></span><br><span class="line">  <span class="keyword">return</span> list(vocabSet)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：给定一篇文档，该文档就会被转换为词向量，</span></span><br><span class="line"><span class="comment">#	        0代表不在输入集中，1代表在输入集中</span></span><br><span class="line"><span class="comment">#param：</span></span><br><span class="line"><span class="comment">#	vocabList ==&gt; 词表</span></span><br><span class="line"><span class="comment">#	inputSet   ==&gt; 输入集</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setOfWords2Vec</span><span class="params">(vocabList, inputSet)</span>:</span></span><br><span class="line">  returnVec = [<span class="number">0</span>]*len(vocabList)  <span class="comment">#初始化一个其中所有元素都为0的向量</span></span><br><span class="line">  <span class="keyword">for</span> word <span class="keyword">in</span> inputSet:</span><br><span class="line">  	<span class="keyword">if</span> word <span class="keyword">in</span> vocabList:</span><br><span class="line">  		returnVec[vocabList.index(word)] = <span class="number">1</span></span><br><span class="line">  	<span class="keyword">else</span>:</span><br><span class="line">  		<span class="keyword">print</span> <span class="string">'the word: =%s is not in my vocabulary!'</span> %word</span><br><span class="line">  <span class="keyword">return</span> returnVec</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：朴素贝叶斯分类器训练函数</span></span><br><span class="line"><span class="comment">#param：</span></span><br><span class="line"><span class="comment">#	trainMatrix       ==&gt; 训练矩阵（由0,1词向量组成）</span></span><br><span class="line"><span class="comment">#	trainCategory  ==&gt; 训练矩阵的分类，0为正常言论，1为侮辱性文字</span></span><br><span class="line"><span class="comment"># 根据现实情况修改分类器：</span></span><br><span class="line"><span class="comment">#1. 利用贝叶斯分类器对文档进行分类时，要计算多个概率的乘积以获得文档属于某个类别的概率，</span></span><br><span class="line"><span class="comment">#	即计算p(w0|c1)p(w1|c1)p(w2|c1)...。如果其中一个概率值为0，那么最后的乘积也为0。</span></span><br><span class="line"><span class="comment">#	为了降低这种影响，可以将所有词的出现数初始化为1，并将分母初始化为2。</span></span><br><span class="line"><span class="comment">#2.另一个问题是下溢出，这是由于太多很小的数相乘造成的。当计算乘积p(w0|c1)p(w1|c1)p(w2|c1)...</span></span><br><span class="line"><span class="comment">#	时，由于大部分因子都非常小，所以程序会下溢出或者得到不正确的答案。一种解决办法是对乘积取自然对数。</span></span><br><span class="line"><span class="comment">#	在代数中有ln(a*b) = ln(a) + ln(b)，于是通过求对数可以避免下溢出或者浮点数导致的错误。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trainNB0</span><span class="params">(trainMatrix, trainCategory)</span>:</span></span><br><span class="line">  numTrainDocs = len(trainMatrix) <span class="comment">#文档数</span></span><br><span class="line">  numWords = len(trainMatrix[<span class="number">0</span>]) <span class="comment">#文档中单词的数目</span></span><br><span class="line">  pAbusive    = sum(trainCategory)/float(numTrainDocs) <span class="comment">#侮辱性文档出现的概率</span></span><br><span class="line">  p0Num = ones(numWords) <span class="comment">#初始化零向量，用于正常文档中的单词</span></span><br><span class="line">  p1Num = ones(numWords) <span class="comment">#初始化零向量，用于侮辱性文档中的单词</span></span><br><span class="line">  p0Denom = <span class="number">2.0</span></span><br><span class="line">  p1Denom = <span class="number">2.0</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(numTrainDocs):</span><br><span class="line">  	<span class="keyword">if</span> trainCategory[i] == <span class="number">1</span>:</span><br><span class="line">  		p1Num += trainMatrix[i]</span><br><span class="line">  		p1Denom += sum(trainMatrix[i])</span><br><span class="line">  	<span class="keyword">else</span>:</span><br><span class="line">  		p0Num += trainMatrix[i]</span><br><span class="line">  		p0Denom += sum(trainMatrix[i])</span><br><span class="line">  p1Vect = log(p1Num/p1Denom)</span><br><span class="line">  p0Vect = log(p0Num/p0Denom)</span><br><span class="line">  <span class="keyword">return</span> p0Vect, p1Vect, pAbusive</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：朴素贝叶斯分类函数</span></span><br><span class="line"><span class="comment">#param：</span></span><br><span class="line"><span class="comment">#	vec2Classify ==&gt; 要分类的向量</span></span><br><span class="line"><span class="comment">#	p0Vec            ==&gt; trainNB0函数返回的p0Vect</span></span><br><span class="line"><span class="comment">#	p1Vec 	         ==&gt; trainNB0函数返回的p1Vect</span></span><br><span class="line"><span class="comment">#	pClass1         ==&gt; trainNB0函数返回的pAbusive</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classifyNB</span><span class="params">(vec2Classify, p0Vec, p1Vec, pClass1)</span>:</span></span><br><span class="line">  p1 = sum(vec2Classify * p1Vec) + log(pClass1) <span class="comment">#因为取了对数，所以概率相乘变为了相加</span></span><br><span class="line">  p0 = sum(vec2Classify * p0Vec) + log(<span class="number">1.0</span> - pClass1) </span><br><span class="line">  <span class="keyword">if</span> p1 &gt; p0:</span><br><span class="line">  	<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：测试函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testingNB</span><span class="params">()</span>:</span></span><br><span class="line">  list0Posts, listClasses = loadDataSet()</span><br><span class="line">  myVocabList = createVocabList(list0Posts)</span><br><span class="line">  trainMat = [] <span class="comment">#把文档矩阵转换为词向量矩阵</span></span><br><span class="line">  <span class="keyword">for</span> postinDoc <span class="keyword">in</span> list0Posts:</span><br><span class="line">  	trainMat.append(setOfWords2Vec(myVocabList, postinDoc))</span><br><span class="line">  p0V,p1V,pAb = trainNB0(trainMat, listClasses) <span class="comment">#训练函数</span></span><br><span class="line">  testEntry = [<span class="string">'love'</span>, <span class="string">'my'</span>, <span class="string">'dalmation'</span>]</span><br><span class="line">  thisDoc = setOfWords2Vec(myVocabList, testEntry)  <span class="comment">#转化为词向量</span></span><br><span class="line">  <span class="keyword">print</span> testEntry,<span class="string">'classified as: '</span>, classifyNB(thisDoc, p0V, p1V, pAb) <span class="comment">#分类函数</span></span><br><span class="line">  testEntry = [<span class="string">'stupid'</span>, <span class="string">'garbage'</span>]</span><br><span class="line">  thisDoc = setOfWords2Vec(myVocabList, testEntry)</span><br><span class="line">  <span class="keyword">print</span> testEntry,<span class="string">'classified as: '</span>, classifyNB(thisDoc, p0V, p1V, pAb)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：朴素贝叶斯次贷模型</span></span><br><span class="line"><span class="comment">#param：</span></span><br><span class="line"><span class="comment">#	vocabList ==&gt; 词表</span></span><br><span class="line"><span class="comment">#	inputSet   ==&gt; 输入集</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bagOfWords2VecMN</span><span class="params">(vocabList, inputSet)</span>:</span></span><br><span class="line">  returnVec = [<span class="number">0</span>]*len(vocabList)</span><br><span class="line">  <span class="keyword">for</span> word <span class="keyword">in</span> inputSet:</span><br><span class="line">  	<span class="keyword">if</span> word <span class="keyword">in</span> vocabList:</span><br><span class="line">  		returnVec[vocabList.index(word)] += <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> returnVec</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：文本解析</span></span><br><span class="line"><span class="comment">#param：</span></span><br><span class="line"><span class="comment">#	bigString ==&gt; 文本</span></span><br><span class="line"><span class="comment">#关于正则表达式：</span></span><br><span class="line"><span class="comment">#	\d  ==&gt; [0-9]</span></span><br><span class="line"><span class="comment">#	\D ==&gt; 非 \d</span></span><br><span class="line"><span class="comment">#	\s  ==&gt; 表示空字符</span></span><br><span class="line"><span class="comment">#	\S  ==&gt; 非空字符</span></span><br><span class="line"><span class="comment">#	\w ==&gt; [a-zA-Z0-9_]</span></span><br><span class="line"><span class="comment">#	\W ==&gt; 非 \w</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">textParse</span><span class="params">(bigString)</span>:</span></span><br><span class="line">  <span class="keyword">import</span> re</span><br><span class="line">  listOfTokens = re.split(<span class="string">r'\W*'</span>, bigString)</span><br><span class="line">  <span class="keyword">return</span> [tok.lower() <span class="keyword">for</span> tok <span class="keyword">in</span> listOfTokens <span class="keyword">if</span> len(tok)&gt;<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：垃圾邮件测试</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spamTest</span><span class="params">()</span>:</span></span><br><span class="line">  docList = [] <span class="comment">#文档列表</span></span><br><span class="line">  classList = [] <span class="comment">#类别列表</span></span><br><span class="line">  <span class="comment">#垃圾邮件文本和普通邮件文本都是25个</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">26</span>):</span><br><span class="line">  	wordList = textParse(open(<span class="string">'email/spam/%d.txt'</span> %i).read())</span><br><span class="line">  	docList.append(wordList)</span><br><span class="line">  	classList.append(<span class="number">1</span>)</span><br><span class="line">  	wordList = textParse(open(<span class="string">'email/ham/%d.txt'</span> %i).read())</span><br><span class="line">  	docList.append(wordList)</span><br><span class="line">  	classList.append(<span class="number">0</span>)</span><br><span class="line">  vocabList = createVocabList(docList) <span class="comment">#初始化词表</span></span><br><span class="line">  trainingSet = range(<span class="number">50</span>)</span><br><span class="line">  testSet = []</span><br><span class="line">  <span class="comment">#从训练集合中随机拿出10个样本作为测试样本，这样训练集合还剩40个样本</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">  	randIndex = int(random.uniform(<span class="number">0</span>, len(trainingSet)))</span><br><span class="line">  	testSet.append(trainingSet[randIndex])</span><br><span class="line">  	<span class="keyword">del</span>(trainingSet[randIndex])</span><br><span class="line">  trainMat = []</span><br><span class="line">  trainClasses = []</span><br><span class="line">  <span class="comment">#训练集</span></span><br><span class="line">  <span class="keyword">for</span> docIndex <span class="keyword">in</span> trainingSet:</span><br><span class="line">  	trainMat.append(bagOfWords2VecMN(vocabList, docList[docIndex]))</span><br><span class="line">  	trainClasses.append(classList[docIndex])</span><br><span class="line">  p0V,p1V,pSpam = trainNB0(trainMat, trainClasses)</span><br><span class="line">  errorCount = <span class="number">0</span></span><br><span class="line">  <span class="comment">#测试集</span></span><br><span class="line">  <span class="keyword">for</span> docIndex <span class="keyword">in</span> testSet:</span><br><span class="line">  	wordVector = bagOfWords2VecMN(vocabList, docList[docIndex])</span><br><span class="line">  	<span class="keyword">if</span> classifyNB(wordVector, p0V, p1V, pSpam) != classList[docIndex]:</span><br><span class="line">  		errorCount += <span class="number">1</span></span><br><span class="line">  		<span class="keyword">print</span> <span class="string">"classification error"</span>,docList[docIndex]</span><br><span class="line">  <span class="keyword">print</span> <span class="string">'the error rate is: '</span>,float(errorCount)/len(testSet)</span><br></pre></td></tr></table></figure>
<p> [参考资料]</p>
<ol>
<li><a href="">机器学习实战</a></li>
<li><a href="http://pan.baidu.com/s/1eQEOOCU" target="_blank" rel="external">本文用到的代码与数据样本</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[最近在看一本叫做机器学习实战的书，感觉写的不错，因为它里面不仅仅讲一些算法的原理，而且最关键的是用python代码实现了其中的应用场景。这里就是一些读书笔记，这次记录的是基于概率论的分类方法：朴素贝叶斯。]]>
    
    </summary>
    
      <category term="机器学习" scheme="https://ningban.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Machine Learning" scheme="https://ningban.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[决策树算法之ID3算法]]></title>
    <link href="https://ningban.github.io/2015/03/20/ID3-algorithm/"/>
    <id>https://ningban.github.io/2015/03/20/ID3-algorithm/</id>
    <published>2015-03-20T12:58:47.000Z</published>
    <updated>2015-03-24T13:06:43.000Z</updated>
    <content type="html"><![CDATA[<h1 id="决策树引论">决策树引论</h1><p>　　如果你以前没有接触过决策树，完全不用担心，它的概念非常简单。即使不知道它也可以通过简单的图像了解其工作原理，图3-1所示的流程图就是一个决策树，正方形代表判断模块，椭圆形代表终止模块，表示已经得出结论，可以终止运行。从判断模块引出的左右箭头称作分支，它可以到达量一个判断模块或者终止模块。图3-1构造了一个假想的邮件分类系统，它首先检测发送邮件域名地址。如果地址位myEmployer.com，则将其放在分类“无聊时需要阅读的邮件”中。如果邮件不是来自这个域名，则检查邮件内容里是否包含单词曲棍球，如果包含则将邮件归类到“需要即使处理的朋友邮件”，如果不包含则将邮件归类到“无序阅读的垃圾邮件”。<br><img src="http://7vihec.com1.z0.glb.clouddn.com/mlp-decisionImg.jpg" alt="原书 图3-1"></p>
<h1 id="决策树的构造">决策树的构造</h1><p>　　在构造决策树时，我们需要解决的第一个问题就是，当前数据集上哪些特征在划分数据分类时其决定性作用。为了找到决定性的特征，划分出最好的结果，我们必须评估每个特征。完成测试之后，原始数据集就被划分为几个数据子集。这些数据子集会分布在第一个决策点的所有分支上。如果某个分支下的数据属于同一个类型，则当前无需阅读的垃圾邮件已经正确地划分数据分类，无序进一步对数据集进行分割。如果数据子集内的数据不属于同一类型，则需要重复划分数据子集的过程。如果划分数据子集的算法和划分原始数据集的方法相同，知道所有具有相同类型的数据均在一个数据子集内。</p>
<h2 id="决策树的一般流程">决策树的一般流程</h2><p>　　1. 收集数据：可以使用任何方法；<br>　　2. 准备数据：树构造算法只适用于标称型数据，因此数值型数据必须离散化；<br>　　3. 分析数据：可以使用任何方法，构造树完成之后，我们应该检查图形是否符合预期；<br>　　4. 训练算法：构造树的数据结构；<br>　　5. 测试算法：使用经验树计算错误率；<br>　　6. 使用算法：此步骤可以适用于任何监督学习算法，而使用决策树可以更好地理解数据的内在含义。</p>
<h2 id="信息增益的概念">信息增益的概念</h2><p>　　划分数据集的最大原则是：将无序的数据变得更加有序。组织杂乱无章数据的一种方法就是使用信息论度量信息。在划分数据集之前之后信息发生的变化称为<code>信息增益</code>。知道如何计算信息增益，我们就可以计算每个特征值划分数据集获得的信息增益，获得信息增益最高的特征就是最好的选择。<br>　　载可以评测哪种数据划分方式是最好的数据划分之前，我们必须学习如何计算信息增益。集合信息的度量方式称为香农熵或者简称熵，这个名字来源于信息论之父克劳德-香农。<br>　　<code>熵</code>定义为信息的期望，熵越高，则混合的数据的种类也越多，在明晰信息增益这个概念之前，我们必须知道信息的定义。如果待分类的事物可能划分在多个分类之中，则符号<img style="padding-top:0px;" src="http://chart.apis.google.com/chart?cht=tx&chl=x_i">的<code>信息</code>定义为：<br><img src="http://chart.apis.google.com/chart?cht=tx&chl=l(x_i) = -log_2 p(x_i) " style=" clear: both;display: block;margin:auto;"><br>　　其中<img style="padding-top:0px;" src="http://chart.apis.google.com/chart?cht=tx&chl=p(x_i)">是选择该分类的概率。<br>　　为了计算熵，我们需要计算所有类别所有可能值包含的信息期望值，通过下面的公式得到：<br><img src="http://chart.apis.google.com/chart?cht=tx&chl=H = -\sum_{i=1}^n p(x_i) log_2 p(x_i) " style=" clear: both;display: block;margin:auto;"><br>　　其中n是分类的数目。</p>
<h2 id="划分数据集">划分数据集</h2><p>　　上面我们学习了如何度量数据集的无序程度，分类算法除了需要测量信息熵，还需要划分数据集，度量划分数据集的熵，以便判断当前是否正确地划分了数据集。我们将对每个特征划分数据集的结果计算一次信息熵，然后判断按照哪个特征划分数据及使最好的划分方式。</p>
<h2 id="递归构建决策树">递归构建决策树</h2><p>　　目前我们已经学习了从数据集构造决策树算法所需要的子功能模块，其工作原理如下：得到原始数据集，然后基于最好的属性值划分数据集，由于特征值可能多于两个，因此可能存在大于两个分支的数据集划分。第一次划分之后，数据将被传递到树分支的下一个节点，在这个节点上，我们可以再次划分数据。因此我们可以采用递归的原则处理数据集。<br>　　递归结束的条件是：程序遍历完所有划分数据集的属性，或者每个分支下的所有实例都具有相同的分类。如果数据集已经处理了所有属性，但是类标签依然不是唯一的，此时我们需要决定如何定义该叶子节点，载这种情况下，我们通常采用多数表决的方法决定该叶子节点的分类。</p>
<h2 id="决策树代码实现">决策树代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#Filename: trees.py</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：创建数据集</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createDataSet</span><span class="params">()</span>:</span></span><br><span class="line">  dataSet = [[<span class="number">1</span>, <span class="number">1</span>, <span class="string">'yes'</span>], </span><br><span class="line">		[<span class="number">1</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</span><br><span class="line">		[<span class="number">1</span>, <span class="number">0</span>, <span class="string">'no'</span>],</span><br><span class="line">		[<span class="number">0</span>, <span class="number">1</span>, <span class="string">'no'</span>],</span><br><span class="line">		[<span class="number">0</span>, <span class="number">1</span>, <span class="string">'no'</span>]]</span><br><span class="line">  labels = [<span class="string">'no surfacing'</span>, <span class="string">'flippers'</span>]</span><br><span class="line">  <span class="keyword">return</span> dataSet, labels</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：计算给定数据集的香农熵</span></span><br><span class="line"><span class="comment">#param：</span></span><br><span class="line"><span class="comment">#	dataset ==&gt; 数据集</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcShannonEnt</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">  numEntries = len(dataSet)</span><br><span class="line">  labelCounts = &#123;&#125;</span><br><span class="line">  <span class="comment">#为所有可能的分类创建字典，key中存放的是类别，value中存储的是属于该类别的个数</span></span><br><span class="line">  <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:</span><br><span class="line">  	currentLabel = featVec[-<span class="number">1</span>]</span><br><span class="line">  	<span class="keyword">if</span> currentLabel <span class="keyword">not</span> <span class="keyword">in</span> labelCounts.keys():</span><br><span class="line">  		labelCounts[currentLabel] = <span class="number">0</span></span><br><span class="line">  	labelCounts[currentLabel] += <span class="number">1</span></span><br><span class="line">  shannonEnt = <span class="number">0.0</span></span><br><span class="line">  <span class="comment">#计算香农熵</span></span><br><span class="line">  <span class="keyword">for</span> key <span class="keyword">in</span> labelCounts:</span><br><span class="line">  	prob = float(labelCounts[key])/numEntries</span><br><span class="line">  	shannonEnt -= prob * log(prob, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">return</span> shannonEnt</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：按照给定特征划分数据集</span></span><br><span class="line"><span class="comment">#param：</span></span><br><span class="line"><span class="comment">#	dataSet ==&gt; 数据集</span></span><br><span class="line"><span class="comment">#	axis       ==&gt; 特征列下标</span></span><br><span class="line"><span class="comment">#	value    ==&gt; 属性值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">splitDataSet</span><span class="params">(dataSet, axis, value)</span>:</span></span><br><span class="line">  retDataSet = []</span><br><span class="line">  <span class="comment">#抽取出axis特征列属性值为value的列表</span></span><br><span class="line">  <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:</span><br><span class="line">  	<span class="keyword">if</span> featVec[axis] == value:</span><br><span class="line">  		reducedFeatVec = featVec[:axis]</span><br><span class="line">  		reducedFeatVec.extend(featVec[axis+<span class="number">1</span>:])</span><br><span class="line">  		retDataSet.append(reducedFeatVec)</span><br><span class="line">  <span class="keyword">return</span> retDataSet</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：选择最好的数据集划分方式</span></span><br><span class="line"><span class="comment">#param：</span></span><br><span class="line"><span class="comment">#	dataSet ==&gt; 数据集</span></span><br><span class="line"><span class="comment">#在函数中调用的数据需要满足一定的要求：</span></span><br><span class="line"><span class="comment">#	1. 数据必须是一种由列表元素组成的列表，而且所有的列表元素都要具有相同的数据长度；</span></span><br><span class="line"><span class="comment">#	2. 数据的最后一列或者每个实例的最后一个元素是当前实例的类标签。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chooseBestFeatureToSplit</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">  numFeatures = len(dataSet[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">  baseEntropy = calcShannonEnt(dataSet)</span><br><span class="line">  bestInfoGain = <span class="number">0.0</span></span><br><span class="line">  bestFeature = -<span class="number">1</span></span><br><span class="line">  <span class="comment">#遍历每个特征</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(numFeatures):</span><br><span class="line">  	<span class="comment">#获得i列特征的所有属性值</span></span><br><span class="line">  	featList = [example[i] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">  	uniqueVals = set(featList)</span><br><span class="line">  	newEntropy = <span class="number">0.0</span></span><br><span class="line">  	<span class="comment">#计算每种划分方式的信息熵</span></span><br><span class="line">  	<span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</span><br><span class="line">  		subDataSet = splitDataSet(dataSet, i, value)</span><br><span class="line">  		prob = len(subDataSet)/float(len(dataSet))</span><br><span class="line">  		newEntropy += prob * calcShannonEnt(subDataSet)</span><br><span class="line">  	infoGain = baseEntropy - newEntropy</span><br><span class="line">  	<span class="comment">#选择信息增益最大的作为最佳特征</span></span><br><span class="line">  	<span class="keyword">if</span>(infoGain &gt; bestInfoGain):</span><br><span class="line">  		bestInfoGain = infoGain</span><br><span class="line">  		bestFeature = i</span><br><span class="line">  <span class="keyword">return</span> bestFeature</span><br><span class="line"></span><br><span class="line">  <span class="comment">#Function：如果数据已经处理了所有属性，但是类标签依然不是唯一的，此时我们需要决定如何定义该叶子节点，</span></span><br><span class="line">  <span class="comment">#		在这种情况下，我们通常会采用多数表决的方法决定该叶子节点的分类</span></span><br><span class="line">  <span class="comment">#param：</span></span><br><span class="line">  <span class="comment">#	classList ==&gt; 类别列表</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityCnt</span><span class="params">(classList)</span>:</span></span><br><span class="line">  <span class="comment">#创建字典，key值存储类别属性值，value存放该属性值的个数</span></span><br><span class="line">  classCount = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> vote <span class="keyword">in</span> classList:</span><br><span class="line">  	<span class="keyword">if</span> vote <span class="keyword">not</span> <span class="keyword">in</span> classCount.keys():</span><br><span class="line">  		classCount[vote] = <span class="number">0</span></span><br><span class="line">  	classCount[vote] += <span class="number">1</span></span><br><span class="line">  <span class="comment"># 按照属性值的个数，从大到小排序</span></span><br><span class="line">  sortedClassCount = sorted(classCount.iteritems(),</span><br><span class="line">  	key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="keyword">True</span>)</span><br><span class="line">  <span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：创建树的函数代码</span></span><br><span class="line"><span class="comment">#param：</span></span><br><span class="line"><span class="comment">#	dataSet ==&gt; 数据集</span></span><br><span class="line"><span class="comment">#	labels    ==&gt; 特征列名称</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createTree</span><span class="params">(dataSet, labels)</span>:</span></span><br><span class="line">  <span class="comment">#类别列表</span></span><br><span class="line">  classList = [example[-<span class="number">1</span>] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">  <span class="comment">#若类别完全相同，则停止继续划分，并返回类别</span></span><br><span class="line">  <span class="keyword">if</span> classList.count(classList[<span class="number">0</span>]) == len(classList):</span><br><span class="line">  	<span class="keyword">return</span> classList[<span class="number">0</span>]</span><br><span class="line">  <span class="comment">#若遍历完所有特征时，但类别依然不唯一，则返回出现次数最多的类别</span></span><br><span class="line">  <span class="keyword">if</span> len(dataSet[<span class="number">0</span>]) == <span class="number">1</span>:</span><br><span class="line">  	<span class="keyword">return</span> majorityCnt(classList)</span><br><span class="line">  <span class="comment">#选择最佳的特征的下标</span></span><br><span class="line">  bestFeat = chooseBestFeatureToSplit(dataSet)</span><br><span class="line">  <span class="comment">#获得最佳的特征名称</span></span><br><span class="line">  bestFeatLabel = labels[bestFeat]</span><br><span class="line">  <span class="comment">#字典变量myTree，存储了树的所有信息</span></span><br><span class="line">  myTree = &#123;bestFeatLabel:&#123;&#125;&#125;</span><br><span class="line">  <span class="keyword">del</span>(labels[bestFeat])</span><br><span class="line">  <span class="comment">#得到最佳特征列包含的所有值</span></span><br><span class="line">  featValues = [example[bestFeat] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">  uniqueVals = set(featValues)</span><br><span class="line">  <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</span><br><span class="line">  	subLabels = labels[:]</span><br><span class="line">  	<span class="comment">#划分数据集</span></span><br><span class="line">  	tmpDataSet = splitDataSet(dataSet, bestFeat, value)</span><br><span class="line">  	<span class="comment">#创建树结构</span></span><br><span class="line">  	myTree[bestFeatLabel][value] = createTree(tmpDataSet, subLabels)</span><br><span class="line">  <span class="keyword">return</span> myTree</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：使用决策树的分类函数</span></span><br><span class="line"><span class="comment">#param：</span></span><br><span class="line"><span class="comment">#	inputTree：字典树</span></span><br><span class="line"><span class="comment">#	featLabels：标签，或者叫做列的名称</span></span><br><span class="line"><span class="comment">#	testVec：     测试向量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classify</span><span class="params">(inputTree, featLabels, testVec)</span>:</span></span><br><span class="line">  firstStr = inputTree.keys()[<span class="number">0</span>]</span><br><span class="line">  secondDict = inputTree[firstStr]</span><br><span class="line">  featIndex = featLabels.index(firstStr) <span class="comment">#将标签字符串转换为索引</span></span><br><span class="line">  <span class="keyword">if</span> type(secondDict).__name__ != <span class="string">'dict'</span>:</span><br><span class="line">  	<span class="keyword">return</span> secondDict</span><br><span class="line">  <span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():</span><br><span class="line">  	<span class="keyword">if</span> testVec[featIndex] == key:</span><br><span class="line">  		<span class="keyword">if</span> type(secondDict[key]).__name__ == <span class="string">'dict'</span>:</span><br><span class="line">  			classLabel = classify(secondDict[key], featLabels, testVec)</span><br><span class="line">  		<span class="keyword">else</span>:</span><br><span class="line">  			classLabel = secondDict[key]</span><br><span class="line">  <span class="keyword">return</span> classLabel</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：使用pickle模块存储决策树</span></span><br><span class="line"><span class="comment">#param：</span></span><br><span class="line"><span class="comment">#	inputTree ==&gt; 决策树</span></span><br><span class="line"><span class="comment">#	filename  ==&gt; 文件名</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">storeTree</span><span class="params">(inputTree, filename)</span>:</span></span><br><span class="line">  <span class="keyword">import</span> pickle</span><br><span class="line">  fw = open(filename, <span class="string">'w'</span>)</span><br><span class="line">  pickle.dump(inputTree, fw)</span><br><span class="line">  fw.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：使用pickle模块获取存储的决策树</span></span><br><span class="line"><span class="comment">#param：</span></span><br><span class="line"><span class="comment">#	filename ==&gt; 文件名</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grabTree</span><span class="params">(filename)</span>:</span></span><br><span class="line">  <span class="keyword">import</span> pickle</span><br><span class="line">  fr = open(filename)</span><br><span class="line">  <span class="keyword">return</span> pickle.load(fr)</span><br></pre></td></tr></table></figure>
<h2 id="决策树画图展示">决策树画图展示</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#-*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="comment">#FileName: treePlotter.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment">#定义数树节点格式的常量</span></span><br><span class="line"><span class="comment">#boxystle控制节点的边框样式，fc控制节点的背景色</span></span><br><span class="line">decisionNode = dict(boxstyle=<span class="string">'sawtooth'</span>, fc=<span class="string">'0.8'</span>)</span><br><span class="line">leafNode = dict(boxstyle=<span class="string">'round4'</span>, fc=<span class="string">'0.8'</span>)</span><br><span class="line">arrow_args = dict(arrowstyle=<span class="string">'&lt;-'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：画节点</span></span><br><span class="line"><span class="comment">#param：</span></span><br><span class="line"><span class="comment">#	nodeTxt    ==&gt; 节点的文本</span></span><br><span class="line"><span class="comment">#	centerPt    ==&gt; 节点正中心的坐标</span></span><br><span class="line"><span class="comment">#	parentPt    ==&gt; 指向节点的点的坐标</span></span><br><span class="line"><span class="comment">#	nodeType  ==&gt; 指向节点的点的样式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotNode</span><span class="params">(nodeTxt, centerPt, parentPt, nodeType)</span>:</span></span><br><span class="line">  createPlot.axl.annotate(nodeTxt, xy=parentPt, xycoords=<span class="string">'axes fraction'</span>,</span><br><span class="line">  	xytext=centerPt, textcoords=<span class="string">'axes fraction'</span>, va=<span class="string">'center'</span>, ha =<span class="string">'center'</span>, </span><br><span class="line">  	bbox=nodeType, arrowprops=arrow_args)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：画图</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createPlot</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="comment">#创建新图形</span></span><br><span class="line">  fig = plt.figure(<span class="number">1</span>, facecolor=<span class="string">'white'</span>) <span class="comment">#facecolor为图像的背景色</span></span><br><span class="line">  fig.clf() <span class="comment">#清空绘图区clf（clear figure）</span></span><br><span class="line">  createPlot.axl = plt.subplot(<span class="number">111</span>, frameon=<span class="keyword">False</span>)</span><br><span class="line">  plotNode(<span class="string">'a decision node'</span>, (<span class="number">0.5</span>, <span class="number">0.1</span>), (<span class="number">0.1</span>, <span class="number">0.5</span>), decisionNode)</span><br><span class="line">  plotNode(<span class="string">'a leaf node'</span>, (<span class="number">0.8</span>, <span class="number">0.1</span>), (<span class="number">0.3</span>, <span class="number">0.8</span>), leafNode)</span><br><span class="line">  plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：获取叶节点的数目</span></span><br><span class="line"><span class="comment">#param:</span></span><br><span class="line"><span class="comment">#	myTree ==&gt; 字典树</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getNumLeafs</span><span class="params">(myTree)</span>:</span></span><br><span class="line">  numLeafs = <span class="number">0</span></span><br><span class="line">  firstStr = myTree.keys()[<span class="number">0</span>]</span><br><span class="line">  secondDict = myTree[firstStr]</span><br><span class="line">  <span class="keyword">if</span> type(secondDict).__name__ != <span class="string">'dict'</span>:</span><br><span class="line">  	numLeafs += <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">  	<span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():</span><br><span class="line">  		<span class="keyword">if</span> type(secondDict[key]).__name__ == <span class="string">'dict'</span>:</span><br><span class="line">  			numLeafs += getNumLeafs(secondDict[key])</span><br><span class="line">  		<span class="keyword">else</span>:</span><br><span class="line">  			numLeafs += <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> numLeafs</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：获取树的高度</span></span><br><span class="line"><span class="comment">#param：</span></span><br><span class="line"><span class="comment">#	myTree ==&gt; 字典树</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTreeDepth</span><span class="params">(myTree)</span>:</span></span><br><span class="line">  maxDepth = <span class="number">0</span></span><br><span class="line">  firstStr = myTree.keys()[<span class="number">0</span>]</span><br><span class="line">  secondDict = myTree[firstStr]</span><br><span class="line">  <span class="keyword">if</span> type(secondDict).__name__ != <span class="string">'dict'</span>:</span><br><span class="line">  	thisDepth = <span class="number">0</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">  	<span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():</span><br><span class="line">  		<span class="keyword">if</span> type(secondDict[key]).__name__ == <span class="string">'dict'</span>:</span><br><span class="line">  			thisDepth = <span class="number">1</span> + getTreeDepth(secondDict[key])</span><br><span class="line">  		<span class="keyword">else</span>:</span><br><span class="line">  			thisDepth = <span class="number">1</span></span><br><span class="line">  		<span class="keyword">if</span> thisDepth &gt; maxDepth:</span><br><span class="line">  			maxDepth = thisDepth</span><br><span class="line">  <span class="keyword">return</span> maxDepth</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：存储树的信息，避免了每次测试代码时都要从数据中创建树的麻烦</span></span><br><span class="line"><span class="comment">#param：</span></span><br><span class="line"><span class="comment">#	i ==&gt; 下标索引</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">retrieveTree</span><span class="params">(i)</span>:</span></span><br><span class="line">  listOfTrees = [&#123;<span class="string">'no surfacing'</span>: &#123;<span class="number">0</span>: <span class="string">'no'</span>, <span class="number">1</span>: &#123;<span class="string">'flippers'</span>: \</span><br><span class="line">  		&#123;<span class="number">0</span>: <span class="string">'no'</span>, <span class="number">1</span>: <span class="string">'yes'</span>&#125;&#125;&#125;&#125;,</span><br><span class="line">  	            &#123;<span class="string">'no surfacing'</span>: &#123;<span class="number">0</span>: <span class="string">'no'</span>, <span class="number">1</span>: &#123;<span class="string">'flippers'</span>: \</span><br><span class="line">  		&#123;<span class="number">0</span>: &#123;<span class="string">'head'</span>: &#123;<span class="number">0</span>: <span class="string">'no'</span>, <span class="number">1</span>: <span class="string">'yes'</span>&#125;&#125;, <span class="number">1</span>: <span class="string">'no'</span>&#125;&#125;&#125;&#125;</span><br><span class="line">  		]</span><br><span class="line">  <span class="keyword">return</span> listOfTrees[i]</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：画出父子节点间填充的文本信息</span></span><br><span class="line"><span class="comment">#param：</span></span><br><span class="line"><span class="comment">#	cntrPt        ==&gt; 子节点坐标</span></span><br><span class="line"><span class="comment">#	parentPt   ==&gt; 父节点坐标</span></span><br><span class="line"><span class="comment">#	txtString    ==&gt; 填充的文字</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotMidText</span><span class="params">(cntrPt, parentPt, txtString)</span>:</span></span><br><span class="line">  xMid = (parentPt[<span class="number">0</span>] - cntrPt[<span class="number">0</span>])/<span class="number">2.0</span> + cntrPt[<span class="number">0</span>]</span><br><span class="line">  yMid = (parentPt[<span class="number">1</span>] - cntrPt[<span class="number">1</span>])/<span class="number">2.0</span> + cntrPt[<span class="number">1</span>]</span><br><span class="line">  createPlot.axl.text(xMid, yMid, txtString)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：画决策树的核心函数</span></span><br><span class="line"><span class="comment">#param：</span></span><br><span class="line"><span class="comment">#	myTree    ==&gt; 字典树</span></span><br><span class="line"><span class="comment">#	parentPt  ==&gt; 父节点坐标</span></span><br><span class="line"><span class="comment">#	nodeTxt   ==&gt; 节点内容</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotTree</span><span class="params">(myTree, parentPt, nodeTxt)</span>:</span></span><br><span class="line">  numLeafs = getNumLeafs(myTree) <span class="comment">#叶子节点个数</span></span><br><span class="line">  depth = getTreeDepth(myTree) <span class="comment">#树的高度</span></span><br><span class="line">  firstStr = myTree.keys()[<span class="number">0</span>]</span><br><span class="line">  cntrPt = (plotTree.xOff + (<span class="number">1.0</span> + float(numLeafs))/<span class="number">2.0</span>/plotTree.totalW, plotTree.yOff) <span class="comment">#这里计算x的坐标的方式没看懂？？</span></span><br><span class="line">  plotMidText(cntrPt, parentPt, nodeTxt) <span class="comment">#填充父子节点连线上的内容</span></span><br><span class="line">  plotNode(firstStr, cntrPt, parentPt, decisionNode) <span class="comment">#画出父子节点与其之间的连线</span></span><br><span class="line">  secondDict = myTree[firstStr]</span><br><span class="line">  <span class="comment">#如果决策树不止一个节点</span></span><br><span class="line">  <span class="keyword">if</span> type(secondDict).__name__ == <span class="string">'dict'</span>:</span><br><span class="line">	  plotTree.yOff = plotTree.yOff - <span class="number">1.0</span>/plotTree.totalD</span><br><span class="line">	  <span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():</span><br><span class="line">	  	<span class="keyword">if</span> type(secondDict[key]).__name__ == <span class="string">'dict'</span>:</span><br><span class="line">	  		plotTree(secondDict[key], cntrPt, str(key))</span><br><span class="line">	  	<span class="keyword">else</span>:</span><br><span class="line">	  		plotTree.xOff += <span class="number">1.0</span>/plotTree.totalW</span><br><span class="line">	  		plotNode(secondDict[key], (plotTree.xOff, plotTree.yOff), cntrPt, leafNode)</span><br><span class="line">	  		plotMidText((plotTree.xOff, plotTree.yOff), cntrPt, str(key))</span><br><span class="line">	  plotTree.yOff = plotTree.yOff + <span class="number">1.0</span>/plotTree.totalD</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：创建图</span></span><br><span class="line"><span class="comment">#param：</span></span><br><span class="line"><span class="comment">#	inTree  ==&gt; 字典树</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createPlot</span><span class="params">(inTree)</span>:</span></span><br><span class="line">  fig = plt.figure(<span class="number">1</span>, facecolor=<span class="string">'white'</span>)</span><br><span class="line">  fig.clf()</span><br><span class="line">  axprops = dict(xticks=[], yticks=[]) <span class="comment">#此参数用于去掉x轴，y轴</span></span><br><span class="line">  createPlot.axl = plt.subplot(<span class="number">111</span>, frameon=<span class="keyword">False</span>, **axprops)</span><br><span class="line">  plotTree.totalW = float(getNumLeafs(inTree)) <span class="comment">#总宽</span></span><br><span class="line">  plotTree.totalD = float(getTreeDepth(inTree)) <span class="comment">#总高</span></span><br><span class="line">  plotTree.xOff = -<span class="number">0.5</span>/plotTree.totalW <span class="comment">#这个初始偏移量没看懂为什么这样设置？？</span></span><br><span class="line">  plotTree.yOff = <span class="number">1.0</span> </span><br><span class="line">  plotTree(inTree, (<span class="number">0.5</span>, <span class="number">1.0</span>), <span class="string">' '</span>)</span><br><span class="line">  plt.show()</span><br></pre></td></tr></table></figure>
<p> [参考资料]</p>
<ol>
<li><a href="">机器学习实战</a></li>
<li><a href="http://pan.baidu.com/s/1eQEOOCU" target="_blank" rel="external">本文用到的代码与数据样本</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[最近在看一本叫做机器学习实战的书，感觉写的不错，因为它里面不仅仅讲一些算法的原理，而且最关键的是用python代码实现了其中的应用场景。这里就是一些读书笔记，这次记录的是决策树算法中的ID3算法。]]>
    
    </summary>
    
      <category term="机器学习" scheme="https://ningban.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Machine Learning" scheme="https://ningban.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[k-近邻算法]]></title>
    <link href="https://ningban.github.io/2015/03/19/knn-algorithm/"/>
    <id>https://ningban.github.io/2015/03/19/knn-algorithm/</id>
    <published>2015-03-19T06:20:16.000Z</published>
    <updated>2015-03-21T15:44:48.000Z</updated>
    <content type="html"><![CDATA[<p>　　最近在看一本叫做机器学习实战的书，感觉写的不错，因为它里面不仅仅将一些算法的原理，而且最关键的是用python代码实现了其中的应用场景，这里就是一些读书笔记。这次记录的是k邻近算法kNN，简单地说，k-近邻算法采用测量不同特征值之间的距离的方法进行分类。<br> 　　<code>它的工作原理</code>是：存在一个样本数据集合，也称作训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每一数据与所属分类的对应关系。输入没有标签的数据后，将新数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本集中特征最相似数据（最近邻）的分类标签。一般来说，我们只选择样本数据集中前k个最相似的数据，这就是k-近邻算法中k的出处，通常k是不大于20的整数。最后，选择k个最相似数据中出现次数最多的分类，作为新数据的分类。<br> 　　<code>k-近邻算法的一般流程</code>：<br> 　　1. 收集数据：可以使用任何方法；<br> 　　2. 准备数据：距离计算所需要的数值，最好是结构化的数据格式；<br> 　　3. 分析数据：可以使用任何方法；<br> 　　4. 训练算法：此步骤不是用于k-近邻算法；<br> 　　5. 测试算法：计算错误率；<br> 　　6. 使用算法：首先需要输入样本数据和结构化的输出结果，然后运行k-临近算法判定输入数据分别属于哪个分类，最后应用对计算出的分类执行后续的处理。<br> 　　<code>程序代码如下</code>：<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="comment">#FileName:KNN.py</span></span><br><span class="line"><span class="string">'''</span><br><span class="line">k近邻算法（kNN: k Nearest Neighbors）</span><br><span class="line">Input:      inX: vector to compare to existing dataset (1xN)</span><br><span class="line">            dataSet: size m data set of known vectors (NxM)</span><br><span class="line">            labels: data set labels (1xM vector)</span><br><span class="line">            k: number of neighbors to use for comparison (should be an odd number)</span><br><span class="line">            </span><br><span class="line">Output:     the most popular class label</span><br><span class="line"></span><br><span class="line">'''</span></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> listdir</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建数据集</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createDataSet</span><span class="params">()</span>:</span></span><br><span class="line">    group = array([[<span class="number">1.0</span>,<span class="number">1.1</span>],[<span class="number">1.0</span>,<span class="number">1.0</span>],[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0.1</span>]])</span><br><span class="line">    labels = [<span class="string">'A'</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'B'</span>]</span><br><span class="line">    <span class="keyword">return</span> group,labels</span><br><span class="line"></span><br><span class="line"><span class="comment">#kNN算法具体实现</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classify0</span><span class="params">(inX, dataSet, labels, k)</span>:</span></span><br><span class="line">    dataSetSize = dataSet.shape[<span class="number">0</span>]</span><br><span class="line">    diffMat = tile(inX, (dataSetSize,<span class="number">1</span>)) - dataSet</span><br><span class="line">    sqDiffMat = diffMat**<span class="number">2</span></span><br><span class="line">    sqDistance = sqDiffMat.sum(axis=<span class="number">1</span>)</span><br><span class="line">    distances = sqDistance**<span class="number">0.5</span></span><br><span class="line">    sortedDistIndicies = distances.argsort()</span><br><span class="line">    classCount=&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">	voteIlabel = labels[sortedDistIndicies[i]]</span><br><span class="line">	classCount[voteIlabel] = classCount.get(voteIlabel,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">	sortedClassCount = sorted(classCount.iteritems(),</span><br><span class="line">	 key= operator.itemgetter(<span class="number">1</span>), reverse=<span class="keyword">True</span>)</span><br><span class="line">    <span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#将文本文档转换为矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">file2matrix</span><span class="params">(filename)</span>:</span></span><br><span class="line">    fr = open(filename)</span><br><span class="line">    arrayOLines = fr.readlines()</span><br><span class="line">    numberofLines = len(arrayOLines)</span><br><span class="line">    returnMat = zeros((numberofLines, <span class="number">3</span>))</span><br><span class="line">    classLabelVector = []</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> arrayOLines:</span><br><span class="line">	line = line.strip()</span><br><span class="line">	listFromLine = line.split(<span class="string">'\t'</span>)</span><br><span class="line">	returnMat[index,:]=listFromLine[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">	classLabelVector.append(int(listFromLine[-<span class="number">1</span>]))</span><br><span class="line">	index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> returnMat,classLabelVector</span><br><span class="line"></span><br><span class="line"><span class="comment">#为了解决每个因素影响结果的权重问题，对数据集进行归一化处理</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">autoNorm</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">  minVals = dataSet.min(<span class="number">0</span>)</span><br><span class="line">  maxVals = dataSet.max(<span class="number">0</span>)</span><br><span class="line">  ranges = maxVals - minVals</span><br><span class="line">  normDataSet = zeros(shape(dataSet))</span><br><span class="line">  m = dataSet.shape[<span class="number">0</span>]</span><br><span class="line">  normDataSet = dataSet -tile(minVals, (m,<span class="number">1</span>))</span><br><span class="line">  normDataSet = normDataSet/tile(ranges, (m,<span class="number">1</span>))</span><br><span class="line">  <span class="keyword">return</span> normDataSet, ranges, minVals</span><br><span class="line"></span><br><span class="line"><span class="comment">#================将KNN用于约会网站=============================================================</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">#例1：从数据集合中选择10%作为测试数据集，使用KNN进行预测，并计算算法的错误率</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">datingClassTest</span><span class="params">()</span>:</span></span><br><span class="line">  hoRatio = <span class="number">0.10</span> </span><br><span class="line">  datingDataMat, datingLabels = file2matrix(<span class="string">'datingTestSet.txt'</span>)</span><br><span class="line">  normMat, ranges, minVals = autoNorm(datingDataMat)</span><br><span class="line">  m = normMat.shape[<span class="number">0</span>]</span><br><span class="line">  numTestVecs = int(m*hoRatio)</span><br><span class="line">  errorCount = <span class="number">0.0</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(numTestVecs):</span><br><span class="line">  	classifierResult = classify0(normMat[i,:], normMat[numTestVecs:m],\</span><br><span class="line">  		datingLabels[numTestVecs:m],<span class="number">3</span>)</span><br><span class="line">  	<span class="keyword">print</span> <span class="string">'the classifier came back with: %d, the real answer is :%d'</span>\</span><br><span class="line">  		%(classifierResult, datingLabels[i])</span><br><span class="line">  	<span class="keyword">if</span>(classifierResult != datingLabels[i]):</span><br><span class="line">  		errorCount += <span class="number">1.0</span></span><br><span class="line">  <span class="keyword">print</span> <span class="string">'the total error rate is : %f'</span> %(errorCount/float(numTestVecs))</span><br><span class="line"></span><br><span class="line"><span class="comment">#例2：给定一个人的所需信息，使用KNN进行预测</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classifyPerson</span><span class="params">()</span>:</span></span><br><span class="line">  resultList = [<span class="string">'not at all'</span>, <span class="string">'in samll doses'</span>, <span class="string">'in large doses'</span>]</span><br><span class="line">  percentTats = float(raw_input(\</span><br><span class="line">  	<span class="string">'percetage of time spent playing video games?'</span>))</span><br><span class="line">  ffMiles = float(raw_input(\</span><br><span class="line">  	<span class="string">'frequent fier miles earned per year?'</span>))</span><br><span class="line">  iceCream = float(raw_input(\</span><br><span class="line">  	<span class="string">'liters of ice cream consumed per year?'</span>))</span><br><span class="line">  datingDataMat, datingLabels = file2matrix(<span class="string">'datingTestSet.txt'</span>)</span><br><span class="line">  normMat, ranges, minVals = autoNorm(datingDataMat)</span><br><span class="line">  inArr = array([ffMiles, percentTats, iceCream])</span><br><span class="line">  classifierResult = classify0((inArr-minVals)/ranges, normMat, datingLabels,<span class="number">3</span>)</span><br><span class="line">  <span class="keyword">print</span> <span class="string">'You will probably like this person:'</span>,\</span><br><span class="line">  	resultList[classifierResult-<span class="number">1</span>]   <span class="comment">#index start from 0, data start from 1, so minus 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#==============将KNN用于图像识别======================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将32*32的二进制文本格式的图像转换为1*1024的向量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img2vector</span><span class="params">(filename)</span>:</span></span><br><span class="line">  returnVect = zeros((<span class="number">1</span>, <span class="number">1024</span>))</span><br><span class="line">  fr = open(filename)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">	lineStr = fr.readline()</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">		returnVect[<span class="number">0</span>, <span class="number">32</span>*i+j] = int(lineStr[j]) </span><br><span class="line">  <span class="keyword">return</span> returnVect</span><br><span class="line"></span><br><span class="line"><span class="comment">#手写识别例子</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handwritingClassTest</span><span class="params">()</span>:</span></span><br><span class="line">  hwLabels = []</span><br><span class="line">  trainingFileList = listdir(<span class="string">'trainingDigits'</span>)</span><br><span class="line">  m = len(trainingFileList)</span><br><span class="line">  trainingMat = zeros((m, <span class="number">1024</span>))</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">  	fileNameStr = trainingFileList[i]</span><br><span class="line">  	fileStr = fileNameStr.split(<span class="string">'.'</span>)[<span class="number">0</span>]</span><br><span class="line">  	classNumStr = int(fileStr.split(<span class="string">'_'</span>)[<span class="number">0</span>])</span><br><span class="line">  	hwLabels.append(classNumStr)</span><br><span class="line">  	trainingMat[i, :] = img2vector(<span class="string">'trainingDigits/%s'</span> %fileNameStr)</span><br><span class="line">  testFileList = listdir(<span class="string">'testDigits'</span>)</span><br><span class="line">  errorCount = <span class="number">0.0</span></span><br><span class="line">  mTest = len(testFileList)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(mTest):</span><br><span class="line">  	fileNameStr = testFileList[i]</span><br><span class="line">  	fileStr = fileNameStr.split(<span class="string">'.'</span>)[<span class="number">0</span>]</span><br><span class="line">  	classNumStr = int(fileStr.split(<span class="string">'_'</span>)[<span class="number">0</span>])</span><br><span class="line">  	vectorUnderTest = img2vector(<span class="string">'testDigits/%s'</span> %fileNameStr)</span><br><span class="line">  	classifierResult = classify0(vectorUnderTest, \</span><br><span class="line">  		trainingMat, hwLabels, <span class="number">3</span>)</span><br><span class="line">  	<span class="keyword">print</span> <span class="string">'the classifier came back with: %d, the real answer is : %d'</span>\</span><br><span class="line">  		%(classifierResult, classNumStr)</span><br><span class="line">  	<span class="keyword">if</span>(classifierResult != classNumStr):</span><br><span class="line">  		errorCount += <span class="number">1.0</span></span><br><span class="line">  <span class="keyword">print</span> <span class="string">'\nthe total number of errors is : %d'</span> %errorCount</span><br><span class="line">  <span class="keyword">print</span> <span class="string">'\nthe total error rate is: %f'</span> %(errorCount/float(mTest))</span><br></pre></td></tr></table></figure></p>
<p> [参考资料]</p>
<ol>
<li><a href="">机器学习实战</a></li>
<li><a href="http://pan.baidu.com/s/1eQEOOCU" target="_blank" rel="external">本文用到的代码与数据样本</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[最近在看一本叫做机器学习实战的书，感觉写的不错，因为它里面不仅仅讲一些算法的原理，而且最关键的是用python代码实现了其中的应用场景，这里就是一些读书笔记。这次记录的是k邻近算法k-NN（k-Nearest Neighbor），简单地说，k-近邻算法采用测量不同特征值之间的距离的方法进行分类。]]>
    
    </summary>
    
      <category term="机器学习" scheme="https://ningban.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Machine Learning" scheme="https://ningban.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[升级hexo3遇到的坑]]></title>
    <link href="https://ningban.github.io/2015/03/19/hexo3-is-awesome/"/>
    <id>https://ningban.github.io/2015/03/19/hexo3-is-awesome/</id>
    <published>2015-03-19T04:33:36.000Z</published>
    <updated>2015-03-24T13:26:04.000Z</updated>
    <content type="html"><![CDATA[<p>　　我本来的hexo版本是2.8，现在使用按照<a href="http://hexo.io/docs/" target="_blank" rel="external">官方教程</a>安装的都会默认安装hexo3。最近一直在使用unbuntu系统，但是我的hexo时安装在了windows系统之下，如果想要写一篇博客还需要来回切换系统，太麻烦了（我的是双系统），悲剧就是这样发生的。too young, too simple的我首先采取了windows和ubuntu共享hexo文件夹的办法，我直接执行hexo generate命令，结果肯定是报错了，傻傻我的搜索了半天，不知所以然，就采取了hexo init，悲剧的事情发生了，hexo文件夹下的_config.yml文件被覆盖掉了，我的网站配置就直接会到了原始版，此时的我只能重新配置（PS：此时我用的主体是pacman），当所有的工作都配置好之后，我发现rss和sitemap不好使，最关键的是python代码的样式都没了，经过长时间的搜索，知道了hexo3是个坑的结论，看样螃蟹确实不是那么好吃的。于是乎，我又想办法把hexo降级，最终来到了<a href="https://coderq.com/t/hexojiang-ji-3-dot-0-to-2-dot-8/1851" target="_blank" rel="external">这里</a>。我尝试了n次之后，发现按照作者的方法对我来说不可行，总是报出关于node中js的错误，此时我以为是node的版本问题，之后我又走向了卸载/重装nodejs的不归路。经过一番折腾，发现即使重新安装nodejs，hexo还是会出现和重装之前一样的错误，好吧，我又走了弯路。最后，终于发现pacman不支持hexo3，至此我已经从下午两点搞到了晚上十一点（PS：出去吃饭/喝水/回宿舍等其他繁杂时间），后来发现jacman支持了hexo3，我果断地选择了jacman主题，这个主题是来源于pacman，开发jacman主题的author貌似进入了他梦寐以求的阿里，这里也恭喜他。好了，回归正题，选择新的主题之后，我选择在ubuntu下新建立一个文件夹用于存放hexo文件，之后的一切还是比较顺利的，可惜今早又折腾了一早，因为我又遇到坑了。<br>　　<code>The first坑：</code>执行hexo deploy命令，报出如下错误：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Error:</span> Deployer not <span class="string">found :</span> github</span><br></pre></td></tr></table></figure></p>
<p>解决方法是执行如下命令：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="operator"><span class="keyword">install</span> hexo-deployer-git <span class="comment">--save</span></span></span><br></pre></td></tr></table></figure></p>
<p>同时修改_config.yml：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git      <span class="comment">//github&gt;&gt;git</span></span><br></pre></td></tr></table></figure></p>
<p>　　<code>The second坑：</code>部署到github之后，<a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="external">rss</a>和<a href="https://github.com/hexojs/hexo-generator-sitemap" target="_blank" rel="external">sitemap</a>插件没有起到作用，解决方法是执行如下命令：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="operator"><span class="keyword">install</span> hexo-generator-feed <span class="comment">--save</span></span><br><span class="line">$ npm <span class="keyword">install</span> hexo-generator-sitemap <span class="comment">--save</span></span></span><br></pre></td></tr></table></figure></p>
<p>　　<code>The third坑：</code>（PS：这个不能算坑，只能算是我的问题）多说无法使用，解决方法就是修改jacman主题的_config.yml，把其中的duoshuo_shortname写上你的shortname就可以了，当然首先你要去多说去注册一个账号才行。<br> 　　<code>The fourth坑（大坑）：</code>关于jacman支持LaTex数学公式，jacman里面很简单，只需要在文章开头的front-matter中，加上一行mathjax: true。那么问题来了，什么叫做front-matter呢？请原谅我的对hexo的无知，搜索了之后才知道是文章的md文件中三个短线上面的配置，如title，date等配置，如下所示：<br> <figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">title: <span class="string">"升级hexo3遇到的坑"</span></span><br><span class="line">date: <span class="number">2015</span>-<span class="number">03</span>-<span class="number">19</span> <span class="number">12</span>:<span class="number">33</span>:<span class="number">36</span></span><br><span class="line">categories: Hexo</span><br><span class="line">tags:  [Hexo]</span><br><span class="line">mathjax: true</span><br><span class="line">---</span><br><span class="line">从这里开始是正文<span class="keyword">...</span></span><br></pre></td></tr></table></figure></p>
<p>　　这样配置好之后，我以为就可以随心所欲的写LaTex数学公式了，可惜我又入坑了。这样我们确实可以载本地的服务上即localhost:4000上看到的是正确的公式，但是为毛提交到github上之后就不行啊，也用了tag但是还是不行，搞不定了。最奇葩的是在手机上用uc浏览器访问公式是正常的，但是在电脑上用chrome和firefox都不行，难道是浏览器的解析问题，也可能是jacman对hexo3公式兼容的问题，好了，算了吧，不在这里浪费时间了。然后我又尝试了另一种方法：使用Google的绘图服务。<br>　　<code>Google Chart API</code>是一个非常强大的工具，通过 API 接口，会动态生成一张 png 图片，当然也支持 LaTex 语言。<br>API 调用方式如下：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://chart.apis.google.com/chart?<span class="variable">cht=</span>tx&amp;<span class="variable">chl=</span><span class="variable">E=</span>mc^<span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>　　其中参数<code>cht</code>表示图表类型, <code>tx</code>表示图表类型为tex语言，<code>chl</code>表示图表标注，E=mc^2就是质能守恒方程的 LaTex 语句。在 markdown 中就可以通过引用图片的方式加入进来，其中的style是为了让图片居中，但是因为都是图片，所以页面的加载速度就会变慢。<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;img <span class="variable">src=</span><span class="string">"http://chart.apis.google.com/chart?cht=tx&amp;chl=E=mc^2"</span> </span><br><span class="line">	<span class="variable">style=</span><span class="string">" clear: both;display: block;margin:auto;"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<p>　　显示效果：<br><img src="http://chart.apis.google.com/chart?cht=tx&chl=E=mc^2" style="clear: both;display: block;margin:auto;"><br>　　还有，如果使用的主题是jacman，就像我的博客这样的，还想要达到图片和文字对齐显示的效果的话，需要如下的代码：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果&lt;img <span class="variable">style=</span><span class="string">"padding-top:0px;"</span>  </span><br><span class="line">	<span class="variable">src=</span><span class="string">"http://chart.apis.google.com/chart?cht=tx&amp;chl=p(c_1|x, y) &gt; p(c_2|x, y)"</span> /&gt;，那么属于类别<span class="number">1</span>。</span><br></pre></td></tr></table></figure></p>
<p>　　显示效果：</p>
<hr>
<p>　　如果<img style="padding-top:0px;" src="http://chart.apis.google.com/chart?cht=tx&chl=p(c_1|x, y) > p(c_2|x, y)">，那么属于类别1。</p>
<hr>
<p>　　真是几经波折啊，本来我就要把这个问题放弃解决了，今天偶然想起来了Google的这个API，试了一下，居然行得通，终于搞定了，还是大谷歌厉害。<br>　　对了，忘记说了最后一点，以后一定要先把hexo整个文件夹备份一份，或者至少要备份source文件夹和主题文件夹，以及根目录下的_config.yml文件这三个，否则产生的后果，你懂的。</p>
<p>[参考资料]</p>
<ol>
<li><a href="https://coderq.com/t/hexojiang-ji-3-dot-0-to-2-dot-8/1851" target="_blank" rel="external">Hexo降级3.0 to 2.8</a></li>
<li><a href="https://github.com/wuchong/jacman" target="_blank" rel="external">jacman</a></li>
<li><a href="http://www.cnblogs.com/liulangmao/p/4323064.html" target="_blank" rel="external">使用hexo搭建github.io博客(一)</a></li>
<li><a href="http://hexo.io/docs/" target="_blank" rel="external">Hexo Docs</a></li>
<li><a href="https://github.com/hexojs/hexo/wiki/plugins" target="_blank" rel="external">Hexo Plugins</a></li>
<li><a href="http://wuchong.me" target="_blank" rel="external">Jac’s Blog</a></li>
<li><a href="http://dwayneten.com/2015/02/26/New-Blog/" target="_blank" rel="external">Hello Blog</a></li>
<li><a href="http://lab.yqc.im/img-css-picture-center.html" target="_blank" rel="external">img设置CSS属性使图片居中</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[最近一直在使用unbuntu系统，但是我的hexo时安装在了windows系统之下，如果想要写一篇博客还需要来回切换系统，太麻烦了（我的是双系统），悲剧就是这样发生的。]]>
    
    </summary>
    
      <category term="Hexo" scheme="https://ningban.github.io/tags/Hexo/"/>
    
      <category term="Hexo" scheme="https://ningban.github.io/categories/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Chrome插件推荐]]></title>
    <link href="https://ningban.github.io/2015/03/08/Chrome-Plugins-recommend/"/>
    <id>https://ningban.github.io/2015/03/08/Chrome-Plugins-recommend/</id>
    <published>2015-03-08T11:41:24.000Z</published>
    <updated>2015-03-08T12:48:32.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7vihec.com1.z0.glb.clouddn.com/chrome.jpg" alt="chrome"><br>　　寒假结束了，好久没有写东西了，最近在v2ex上看到12年发表一个关于<a href="https://www.v2ex.com/t/37709" target="_blank" rel="external">好用的Chrome插件</a>的讨论，看了之后收获挺多的，在这里也把我常用的Chrome插件推荐一下，也当作记录之用。</p>
<ul>
<li>SwitchyOmega<blockquote>
<p>这个插件的名字以前叫做Switch Sharp，作者又重新写了一个并且改成了这个名字，原来的由于扩展性问题，不更新了。至于他的功能的话，你懂的，不懂的话，问Google吧。</p>
</blockquote>
</li>
<li>LastPass<blockquote>
<p>自从有了它，密码什么的再也不用担心了，不仅可以记录所有的密码，而且可以自动生成密码，所以以往一个密码通天下的时代结束了。</p>
</blockquote>
</li>
<li>Pocket<blockquote>
<p>这个插件又叫做稍后阅读，就是在浏览网页看到的内容如果没时间看，可以先放在这里，以后可以再在这里看。</p>
</blockquote>
</li>
<li>印象笔记·剪藏<blockquote>
<p>这个和上面的功能基本是一样的，对于代码的保存也更友好一些。</p>
</blockquote>
</li>
<li>Tampermonkey<blockquote>
<p>这个插件可是用一个字”厉害”来形容了，自从有了它，所有网站的自动签到神马的，百度云盘上资源的搜索神马的等等都搞定了。<a href="https://greasyfork.org/zh-CN" target="_blank" rel="external">点这里</a>去找到自己想用的用户脚本吧。</p>
</blockquote>
</li>
<li>Google翻译<blockquote>
<p>这个不用说了吧，就是看英文的时候的划词翻译功能，也支持右键搜索，但是好像需要越过功夫网才可以。</p>
</blockquote>
</li>
<li>Adblock<blockquote>
<p>这个插件用于屏蔽网页上的广告的，当然有些视频网站的广告也是可以的哦。也有些朋友推荐使用μblock，它们的功能大体是差不多的。</p>
</blockquote>
</li>
<li>Better History<blockquote>
<p>这个插件用于有条理的查看Chrome的浏览历史。</p>
</blockquote>
</li>
<li>有道云笔记·剪藏<blockquote>
<p>这个插件和印象笔记的差不多，但是存储空间很大的说。</p>
</blockquote>
</li>
<li>一键管理<blockquote>
<p>这个插件用于管理Chrome上的所有插件，如果所有的插件都运行可能会卡，所以有了它，想开启哪个开启哪个。</p>
</blockquote>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[这里推荐我常用并且非常不错的chrome插件。]]>
    
    </summary>
    
      <category term="分享与发现" scheme="https://ningban.github.io/tags/%E5%88%86%E4%BA%AB%E4%B8%8E%E5%8F%91%E7%8E%B0/"/>
    
      <category term="分享与发现" scheme="https://ningban.github.io/categories/%E5%88%86%E4%BA%AB%E4%B8%8E%E5%8F%91%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python入门笔记]]></title>
    <link href="https://ningban.github.io/2015/01/21/Python-Note/"/>
    <id>https://ningban.github.io/2015/01/21/Python-Note/</id>
    <published>2015-01-21T15:05:44.000Z</published>
    <updated>2015-03-19T06:31:44.000Z</updated>
    <content type="html"><![CDATA[<h1 id="注释">注释</h1><p> 　　Python至少应当有第一行那样的特殊形式的注释。它被称作 组织行 ——源文件的头两个字符是#!，后面跟着一个程序。这行告诉你的Linux/Unix系统当你执行你的程序的时候，它应该运行哪个解释器。注意，你总是可以通过直接在命令行指定解释器，从而在任何平台上运行你的程序，就如同命令python helloworld.py一样。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ chmod a+x helloworld.py</span><br><span class="line">$ ./helloworld.py</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure></p>
<p>　　为了更加有趣一些，你可以把你的文件名改成helloworld，然后运行./helloworld。这样，这个程序仍然可以工作,因为系统知道它必须用源文件第一行指定的那个解释器来运行程序。可以把你的程序保存在PATH环境变量中的目录之一，每当你运行任何程序，系统会查找列在PATH环境变量中的各个目录，然后运行那个程序。</p>
<h1 id="参数">参数</h1><p>　　只有在形参末尾的那些参数可以有默认参数值，即你不能在声明函数形参的时候，先声明有默认值的形参而后声明没有默认值的形参。这是因为赋给形参的值是根据位置而赋值的，例如：def func(a, b=5)是有效的，但是def func(a=5, b)是无效的。</p>
<h1 id="文档字符串DocStrings">文档字符串DocStrings</h1><p>　　文档字符串的惯例是一个多行字符串，它的首行以大写字母开始，句号结尾。第二行是空行，从第三行开始是详细的描述。强烈建议你在你的函数中使用文档字符串时遵循这个惯例。自动化工具也可以以同样的方式从你的程序中提取文档。因此,我强烈建议你对你所写的任何正式函数编写文档字符串。随你的Python发行版附带的pydoc命令，与help()类似地使用DocStrings。</p>
<h1 id="sys模块">sys模块</h1><p>　　sys模块包含了与Python解释器和它的环境有关的函数。<br>　　当Python执行import sys语句的时候，它在sys.path变量所列目录中寻找sys.py模块。如果找到了这个文件，这个模块的主块中的语句将被运行，然后这个模块将能够被你使用。注意，初始化过程仅在我们第一次输入模块的时候进行。<br>　　这里，当我们执行python using_sys.py we are arguments的时候,我们使用python命令运行using_sys.py模块，后面跟着的内容被作为参数传递给程序。Python为我们把它存储在sys.argv变量中。<br>　　<strong>PS：</strong>一般说来，应该避免使用from..import而使用import语句，因为这样可以使你的程序更加易读，也可以避免名称的冲突。</p>
<h1 id="__name__模块">__name__模块</h1><p>　　例如<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: using_name.py</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'This program is being run by itself'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'I am being imported from another module'</span></span><br></pre></td></tr></table></figure></p>
<p>　　这里表示，如果执行python using_name.py时，则__name__=’__main__‘；如果执行import using_name，则__name__=’using_name’。</p>
<h1 id="dir()函数">dir()函数</h1><p>　　你可以使用内建的dir函数来列出模块定义的标识符，识符有函数、类和变量。当你为dir()提供一个模块名的时候,它返回模块定义的名称列表；如果不提供参数，它返回当前模块中定义的名称列表。</p>
<h1 id="数据结构">数据结构</h1><p>　　在Python中有三种内建的数据结构——列表list、元组tuple和字典dict。</p>
<h2 id="列表">列表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: using_list.py</span></span><br><span class="line"><span class="comment"># This is my shopping list</span></span><br><span class="line">shoplist = [<span class="string">'apple'</span>, <span class="string">'mango'</span>, <span class="string">'carrot'</span>, <span class="string">'banana'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'I have'</span>, len(shoplist),<span class="string">'items to purchase.'</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'These items are:'</span>, <span class="comment"># Notice the comma at end of the line</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> shoplist:</span><br><span class="line">    <span class="keyword">print</span> item,</span><br><span class="line"><span class="keyword">print</span> <span class="string">'\nI also have to buy rice.'</span></span><br><span class="line">shoplist.append(<span class="string">'rice'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'My shopping list is now'</span>, shoplist</span><br><span class="line"><span class="keyword">print</span> <span class="string">'I will sort my list now'</span></span><br><span class="line">shoplist.sort()</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Sorted shopping list is'</span>, shoplist</span><br><span class="line"><span class="keyword">print</span> <span class="string">'The first item I will buy is'</span>, shoplist[<span class="number">0</span>]</span><br><span class="line">olditem = shoplist[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">del</span> shoplist[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'I bought the'</span>, olditem</span><br><span class="line"><span class="keyword">print</span> <span class="string">'My shopping list is now'</span>, shoplist</span><br></pre></td></tr></table></figure>
<h2 id="元组">元组</h2><p>　　元组和列表十分类似，只不过元组和字符串一样是不可变的，即你不能修改元组。元组通过圆括号中用逗号分割的项目定义。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: using_tuple.py</span></span><br><span class="line">zoo = (<span class="string">'wolf'</span>, <span class="string">'elephant'</span>, <span class="string">'penguin'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Number of animals in the zoo is'</span>, len(zoo)</span><br><span class="line">new_zoo = (<span class="string">'monkey'</span>, <span class="string">'dolphin'</span>, zoo)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Number of animals in the new zoo is'</span>, len(new_zoo)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'All animals in new zoo are'</span>, new_zoo</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Animals brought from old zoo are'</span>, new_zoo[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Last animal brought from old zoo is'</span>, new_zoo[<span class="number">2</span>][<span class="number">2</span>]</span><br></pre></td></tr></table></figure></p>
<p>　　一个空的元组由一对空的圆括号组成，如myempty = ()。然而，含有单个元素的元组就不那么简单了，你必须在第一个(唯一一个)项目后跟一个逗号,这样Python才能区分元组和表达式中一个带圆括号的对象。即如果你想要的是一个包含项目2的元组的时候，你应该指明singleton = (2 , )。<br>　　元组最通常的用法是用在打印语句中，下面是一个例子:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: print_tuple.py</span></span><br><span class="line">age = <span class="number">22</span></span><br><span class="line">name = <span class="string">'Swaroop'</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'%s is %d years old'</span> % (name, age)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Why is %s playing with that python?'</span> % name</span><br></pre></td></tr></table></figure></p>
<p>　　在第二个print语句中,我们使用了一个定制，后面跟着%符号后的单个项目——没有圆括号，这只在字符串中只有一个定制的时候有效。</p>
<h2 id="字典">字典</h2><p>　　你只能使用不可变的对象(比如字符串)来作为字典的键，但是你可以把不可变或可变的对象作为字典的值。键值对在字典中以这样的方式标记:d = {key1 : value1, key2 : value2 }。注意，它们的键/值对用冒号分割，而各个对用逗号分割，所有这些都包括在花括号中。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: using_dict.py</span></span><br><span class="line"><span class="comment"># 'ab' is short for 'a'ddress'b'ook</span></span><br><span class="line">ab = &#123;</span><br><span class="line">    <span class="string">'Swaroop'</span> : <span class="string">'swaroopch@byteofpython.info'</span>,</span><br><span class="line">    <span class="string">'Larry'</span> : <span class="string">'larry@wall.org'</span>,</span><br><span class="line">    <span class="string">'Matsumoto'</span> : <span class="string">'matz@ruby-lang.org'</span>,</span><br><span class="line">    <span class="string">'Spammer'</span> : <span class="string">'spammer@hotmail.com'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Swaroop's address is %s"</span> % ab[<span class="string">'Swaroop'</span>]</span><br><span class="line"><span class="comment"># Adding a key/value pair</span></span><br><span class="line">ab[<span class="string">'Guido'</span>] = <span class="string">'guido@python.org'</span></span><br><span class="line"><span class="comment"># Deleting a key/value pair</span></span><br><span class="line"><span class="keyword">del</span> ab[<span class="string">'Spammer'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'\nThere are %d contacts in the address-book\n'</span> % len(ab)</span><br><span class="line"><span class="keyword">for</span> name, address <span class="keyword">in</span> ab.items():</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Contact %s at %s'</span> % (name, address)</span><br><span class="line"><span class="keyword">if</span> <span class="string">'Guido'</span> <span class="keyword">in</span> ab: <span class="comment"># OR ab.has_key('Guido')</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"\nGuido's address is %s"</span> % ab[<span class="string">'Guido'</span>]</span><br></pre></td></tr></table></figure></p>
<h1 id="序列">序列</h1><p>　　列表、元组和字符串都是序列，但是序列是什么，它们为什么如此特别呢？序列的两个主要特点是索引操作符和切片操作符。索引操作符让我们可以从序列中抓取一个特定项目。切片操作符让我们能够获取序列的一个切片，即一部分序列。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: seq.py</span></span><br><span class="line">shoplist = [<span class="string">'apple'</span>, <span class="string">'mango'</span>, <span class="string">'carrot'</span>, <span class="string">'banana'</span>]</span><br><span class="line"><span class="comment"># Indexing or 'Subscription' operation</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Item 0 is'</span>, shoplist[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Item 1 is'</span>, shoplist[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Item 2 is'</span>, shoplist[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Item 3 is'</span>, shoplist[<span class="number">3</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Item -1 is'</span>, shoplist[-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Item -2 is'</span>, shoplist[-<span class="number">2</span>]</span><br><span class="line"><span class="comment"># Slicing on a list</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Item 1 to 3 is'</span>, shoplist[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Item 2 to end is'</span>, shoplist[<span class="number">2</span>:]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Item 1 to -1 is'</span>, shoplist[<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Item start to end is'</span>, shoplist[:]</span><br><span class="line"><span class="comment"># Slicing on a string</span></span><br><span class="line">name = <span class="string">'swaroop'</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'characters 1 to 3 is'</span>, name[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'characters 2 to end is'</span>, name[<span class="number">2</span>:]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'characters 1 to -1 is'</span>, name[<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'characters start to end is'</span>, name[:]</span><br></pre></td></tr></table></figure></p>
<p>　　注意，返回的序列从开始位置开始，刚好在结束位置之前结束。即开始位置是包含在序列切片中的，而结束位置被排斥在切片外。</p>
<h1 id="引用">引用</h1><p>　　当你创建一个对象并给它赋一个变量的时候，这个变量仅仅引用那个对象，而不是表示这个对象本身！也就是说，变量名指向你计算机中存储那个对象的内存，这被称作名称到对象的绑定。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: reference.py</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Simple Assignment'</span></span><br><span class="line">shoplist = [<span class="string">'apple'</span>, <span class="string">'mango'</span>, <span class="string">'carrot'</span>, <span class="string">'banana'</span>]</span><br><span class="line">mylist = shoplist <span class="comment"># mylist is just another name pointing to the same object!</span></span><br><span class="line"><span class="keyword">del</span> shoplist[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'shoplist is'</span>, shoplist</span><br><span class="line"><span class="keyword">print</span> <span class="string">'mylist is'</span>, mylist</span><br><span class="line"><span class="comment"># notice that both shoplist and mylist both print the same list without</span></span><br><span class="line"><span class="comment"># the 'apple' confirming that they point to the same object</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Copy by making a full slice'</span></span><br><span class="line">mylist = shoplist[:] <span class="comment"># make a copy by doing a full slice</span></span><br><span class="line"><span class="keyword">del</span> mylist[<span class="number">0</span>] <span class="comment"># remove first item</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'shoplist is'</span>, shoplist</span><br><span class="line"><span class="keyword">print</span> <span class="string">'mylist is'</span>, mylist</span><br><span class="line"><span class="comment"># notice that now the two lists are different</span></span><br></pre></td></tr></table></figure></p>
<p>　　记住列表的赋值语句不创建拷贝，你得使用切片操作符来建立序列的拷贝。</p>
<h1 id="字符串">字符串</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: str_methods.py</span></span><br><span class="line">name = <span class="string">'Swaroop'</span> <span class="comment"># This is a string object</span></span><br><span class="line"><span class="keyword">if</span> name.startswith(<span class="string">'Swa'</span>):</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Yes, the string starts with "Swa"'</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">'a'</span> <span class="keyword">in</span> name:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Yes, it contains the string "a"'</span></span><br><span class="line"><span class="keyword">if</span> name.find(<span class="string">'war'</span>) != -<span class="number">1</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Yes, it contains the string "war"'</span></span><br><span class="line">delimiter = <span class="string">'_*_'</span></span><br><span class="line">mylist = [<span class="string">'Brazil'</span>, <span class="string">'Russia'</span>, <span class="string">'India'</span>, <span class="string">'China'</span>]</span><br><span class="line"><span class="keyword">print</span> delimiter.join(mylist)</span><br></pre></td></tr></table></figure>
<h1 id="例子：文件备份">例子：文件备份</h1><p>　　我认为优化之一是采用更好的文件名机制——使用时间作为文件名，而把当前的日期作为目录名，存放在主备份目录中。这样做的一个优势是你的备份会以等级结构存储,因此它就更加容易管理了。另外一个优势是文件名的长度也可以变短。还有一个优势是采用各自独立的文件夹可以帮助你方便地检验你是否在每一天创建了备份，因为只有在你创建了备份，才会出现那天的目录。<br>　　我还希望有的一个优化是使用tar命令替代zip命令。这样做的一个优势是在你结合使用tar和gzip命令的时候，备份会更快更小。<br>　　最理想的创建这些归档的方法是分别使用zipfile和tarfile。它们是Python标准库的一部分，可以供你使用。使用这些库就避免了使用os.system这个不推荐使用的函数，它容易引发严重的错误。</p>
<h1 id="面向过程与面向对象">面向过程与面向对象</h1><p>　　到目前为止，在我们的程序中，我们都是根据操作数据的函数或语句块来设计程序的。这被称为面向过程的编程。还有一种把数据和功能结合起来，用称为对象的东西包裹起来组织程序的方法。这种方法称为面向对象的编程理念。</p>
<h1 id="self">self</h1><p>　　假如你有一个类称为MyClass和这个类的一个实例MyObject。当你调用这个对象的方法MyObject.method(arg1, arg2)的时候,这会由Python自动转为MyClass.method(MyObject, arg1,arg2)——这就是self的原理了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: method.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayHi</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Hello, how are you?'</span></span><br><span class="line">p = Person()</span><br><span class="line">p.sayHi()</span><br><span class="line"><span class="comment"># This short example can also be written as Person().sayHi()</span></span><br></pre></td></tr></table></figure></p>
<h1 id="__init__与__del__">__init__与__del__</h1><p>　　__init__方法类似于C++、C#和Java中的 constructor 。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: class_init.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayHi</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Hello, my name is'</span>, self.name</span><br><span class="line">p = Person(<span class="string">'Swaroop'</span>)</span><br><span class="line">p.sayHi()</span><br><span class="line"><span class="comment"># This short example can also be written as Person('Swaroop').sayHi()</span></span><br></pre></td></tr></table></figure></p>
<p>　　就如同__init__方法一样，还有一个特殊的方法__del__，它在对象消逝的时候被调用。对象消逝即对象不再被使用，它所占用的内存将返回给系统作它用。当对象不再被使用时，__del__方法运行，但是很难保证这个方法究竟在 什么时候运行。</p>
<h1 id="类与对象的变量">类与对象的变量</h1><p>　　有两种类型的域——类的变量和对象的变量，它们根据是类还是对象拥有这个变量而区分。<br>　　类的变量由一个类的所有对象(实例)共享使用。只有一个类变量的拷贝，所以当某个对象对类的变量做了改动的时候，这个改动会反映到所有其他的实例上。<br>　　对象的变量由类的每个对象/实例拥有。因此每个对象有自己对这个域的一份拷贝，即它们不是共享的，在同一个类的不同实例中，虽然对象的变量有相同的名称，但是是互不相关的。通过一个例子会使这个易于理解。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: objvar.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="string">'''Represents a person.'''</span></span><br><span class="line">    population = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="string">'''Initializes the person's data.'''</span></span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'(Initializing %s)'</span> % self.name</span><br><span class="line">        <span class="comment"># When this person is created, he/she</span></span><br><span class="line">        <span class="comment"># adds to the population</span></span><br><span class="line">        Person.population += <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''I am dying.'''</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'%s says bye.'</span> % self.name</span><br><span class="line">        Person.population -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> Person.population == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'I am the last one.'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'There are still %d people left.'</span> % Person.population</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayHi</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''Greeting by the person.</span><br><span class="line">            Really, that's all it does.'''</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Hi, my name is %s.'</span> % self.name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">howMany</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''Prints the current population.'''</span></span><br><span class="line">        <span class="keyword">if</span> Person.population == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'I am the only person here.'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'We have %d persons here.'</span> % Person.population</span><br><span class="line">swaroop = Person(<span class="string">'Swaroop'</span>)</span><br><span class="line">swaroop.sayHi()</span><br><span class="line">swaroop.howMany()</span><br><span class="line">kalam = Person(<span class="string">'Abdul Kalam'</span>)</span><br><span class="line">kalam.sayHi()</span><br><span class="line">kalam.howMany()</span><br><span class="line">swaroop.sayHi()</span><br><span class="line">swaroop.howMany()</span><br></pre></td></tr></table></figure></p>
<p>　　在这个程序中，我们还看到docstring对于类和方法同样有用。我们可以在运行时使用Person.__doc__和Person.sayHi.__doc__来分别访问类与方法的文档字符串。<br>　　Python中所有的类成员(包括数据成员)都是公共的，所有的方法都是有效的。只有一个例外：如果你使用的数据成员名称以双下划线前缀比如__privatevar，Python的名称管理体系会有效地把它作为私有变量。</p>
<h1 id="继承">继承</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: inherit.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolMember</span>:</span></span><br><span class="line">    <span class="string">'''Represents any school member.'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'(Initialized SchoolMember: %s)'</span> % self.name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tell</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''Tell my details.'''</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Name:"%s" Age:"%s"'</span> % (self.name, self.age),</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span><span class="params">(SchoolMember)</span>:</span></span><br><span class="line">    <span class="string">'''Represents a teacher.'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, salary)</span>:</span></span><br><span class="line">        SchoolMember.__init__(self, name, age)</span><br><span class="line">        self.salary = salary</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'(Initialized Teacher: %s)'</span> % self.name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tell</span><span class="params">(self)</span>:</span></span><br><span class="line">        SchoolMember.tell(self)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Salary: "%d"'</span> % self.salary</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(SchoolMember)</span>:</span></span><br><span class="line">    <span class="string">'''Represents a student.'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, marks)</span>:</span></span><br><span class="line">        SchoolMember.__init__(self, name, age)</span><br><span class="line">        self.marks = marks</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'(Initialized Student: %s)'</span> % self.name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tell</span><span class="params">(self)</span>:</span></span><br><span class="line">        SchoolMember.tell(self)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Marks: "%d"'</span> % self.marks</span><br><span class="line">t = Teacher(<span class="string">'Mrs. Shrividya'</span>, <span class="number">40</span>, <span class="number">30000</span>)</span><br><span class="line">s = Student(<span class="string">'Swaroop'</span>, <span class="number">22</span>, <span class="number">75</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="comment"># prints a blank line</span></span><br><span class="line">members = [t, s]</span><br><span class="line"><span class="keyword">for</span> member <span class="keyword">in</span> members:</span><br><span class="line">    member.tell() <span class="comment"># works for both Teachers and Students</span></span><br></pre></td></tr></table></figure>
<p>　　为了使用继承，我们把基本类的名称作为一个元组跟在定义类时的类名称之后。如果在继承元组中列了一个以上的类，那么它就被称作多重继承 。</p>
<h1 id="文件">文件</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: using_file.py</span></span><br><span class="line">poem = <span class="string">'''\</span><br><span class="line">Programming is fun</span><br><span class="line">When the work is done</span><br><span class="line">if you wanna make your work also fun:</span><br><span class="line">use Python!</span><br><span class="line">'''</span></span><br><span class="line">f = file(<span class="string">'poem.txt'</span>, <span class="string">'w'</span>) <span class="comment"># open for 'w'riting</span></span><br><span class="line">f.write(poem) <span class="comment"># write text to file</span></span><br><span class="line">f.close() <span class="comment"># close the file</span></span><br><span class="line">f = file(<span class="string">'poem.txt'</span>)</span><br><span class="line"><span class="comment"># if no mode is specified, 'r'ead mode is assumed by default</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    line = f.readline()</span><br><span class="line">    <span class="keyword">if</span> len(line) == <span class="number">0</span>: <span class="comment"># Zero length indicates EOF</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">print</span> line,</span><br><span class="line"><span class="comment"># Notice comma to avoid automatic newline added by Python</span></span><br><span class="line">f.close() <span class="comment"># close the file</span></span><br></pre></td></tr></table></figure>
<p>　　在一个循环中，我们使用readline方法读文件的每一行。这个方法返回包括行末换行符的一个完整行。所以，当一个空的字符串被返回的时候，即表示文件末已经到达了，于是我们停止循环。<br>　　<strong>注意：</strong>因为从文件读到的内容已经以换行符结尾，所以我们在print语句上使用逗号来消除自动换行。最后，我们用close关闭这个文件。</p>
<h1 id="持久地储存对象">持久地储存对象</h1><p>　　Python提供一个标准的模块，称为pickle。使用它你可以在一个文件中储存任何Python对象，之后你又可以把它完整无缺地取出来。这被称为持久地储存对象。<br>　　还有另一个模块称为cPickle，它的功能和pickle模块完全相同，只不过它是用C语言编写的，因此要快得多(比pickle快1000倍)。你可以使用它们中的任一个，而我们在这里将使用cPickle模块。记住，我们把这两个模块都简称为pickle模块。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: pickling.py</span></span><br><span class="line"><span class="keyword">import</span> cPickle <span class="keyword">as</span> p</span><br><span class="line"><span class="comment">#import pickle as p</span></span><br><span class="line">shoplistfile = <span class="string">'shoplist.data'</span></span><br><span class="line"><span class="comment"># the name of the file where we will store the object</span></span><br><span class="line">shoplist = [<span class="string">'apple'</span>, <span class="string">'mango'</span>, <span class="string">'carrot'</span>]</span><br><span class="line"><span class="comment"># Write to the file</span></span><br><span class="line">f = file(shoplistfile, <span class="string">'w'</span>)</span><br><span class="line">p.dump(shoplist, f) <span class="comment"># dump the object to a file</span></span><br><span class="line">f.close()</span><br><span class="line"><span class="keyword">del</span> shoplist <span class="comment"># remove the shoplist</span></span><br><span class="line"><span class="comment"># Read back from the storage</span></span><br><span class="line">f = file(shoplistfile)</span><br><span class="line">storedlist = p.load(f)</span><br><span class="line"><span class="keyword">print</span> storedlist</span><br></pre></td></tr></table></figure></p>
<p>　　为了在文件里储存一个对象，首先以写模式打开一个file对象，然后调用储存器模块的dump函数，把对象储存到打开的文件中，这个过程称为储存。接下来，我们使用pickle模块的load函数的返回来取回对象，这个过程称为 取储存 。</p>
<h1 id="异常">异常</h1><h2 id="处理异常">处理异常</h2><p>　　我们可以使用try..except语句来处理异常。我们把通常的语句放在try-块中，而把我们的错误处理语句放在except-块中。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: try_except.py</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    s = raw_input(<span class="string">'Enter something --&gt; '</span>)</span><br><span class="line"><span class="keyword">except</span> EOFError:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\nWhy did you do an EOF on me?'</span></span><br><span class="line">    sys.exit() <span class="comment"># exit the program</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\nSome error/exception occurred.'</span></span><br><span class="line">    <span class="comment"># here, we are not exiting the program</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Done'</span></span><br></pre></td></tr></table></figure></p>
<p>　　你还可以让try..catch块关联上一个else从句，当没有异常发生的时候，else从句将被执行。</p>
<h2 id="引发异常">引发异常</h2><p>　　你可以使用raise语句引发异常，你还得指明错误/异常的名称和伴随异常触发的异常对象。你可以引发的错误或异常应该分别是一个Error或Exception类的直接或间接导出类。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: raising.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShortInputException</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="string">'''A user-defined exception class.'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, length, atleast)</span>:</span></span><br><span class="line">        Exception.__init__(self)</span><br><span class="line">        self.length = length</span><br><span class="line">        self.atleast = atleast</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    s = raw_input(<span class="string">'Enter something --&gt; '</span>)</span><br><span class="line">    <span class="keyword">if</span> len(s) &lt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">raise</span> ShortInputException(len(s), <span class="number">3</span>)</span><br><span class="line">    <span class="comment"># Other work can continue as usual here</span></span><br><span class="line"><span class="keyword">except</span> EOFError:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\nWhy did you do an EOF on me?'</span></span><br><span class="line"><span class="keyword">except</span> ShortInputException, x:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'ShortInputException: The input was of length %d, \</span><br><span class="line">was expecting at least %d'</span> % (x.length, x.atleast)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'No exception was raised.'</span></span><br></pre></td></tr></table></figure></p>
<h2 id="try-finally">try..finally</h2><p>　　假如你在读一个文件的时候，希望在无论异常发生与否的情况下都关闭文件，该怎么做呢？这可以使用finally块来完成。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: finally.py</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = file(<span class="string">'poem.txt'</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>: <span class="comment"># our usual file-reading idiom</span></span><br><span class="line">        line = f.readline()</span><br><span class="line">        <span class="keyword">if</span> len(line) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">print</span> line,</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">f.close()</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Cleaning up...closed the file'</span></span><br></pre></td></tr></table></figure></p>
<h1 id="Python标准库">Python标准库</h1><h2 id="sys模块-1">sys模块</h2><p>　　命令行参数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: cat.py</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readfile</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="string">'''Print a file to the standard output.'''</span></span><br><span class="line">    f = file(filename)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        line = f.readline()</span><br><span class="line">        <span class="keyword">if</span> len(line) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">print</span> line, <span class="comment"># notice comma</span></span><br><span class="line">    f.close()</span><br><span class="line"><span class="comment"># Script starts from here</span></span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &lt; <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'No action specified.'</span></span><br><span class="line">    sys.exit()</span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>].startswith(<span class="string">'--'</span>):</span><br><span class="line">    option = sys.argv[<span class="number">1</span>][<span class="number">2</span>:]</span><br><span class="line">    <span class="comment"># fetch sys.argv[1] but without the first two characters</span></span><br><span class="line">    <span class="keyword">if</span> option == <span class="string">'version'</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Version 1.2'</span></span><br><span class="line">    <span class="keyword">elif</span> option == <span class="string">'help'</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'''\</span><br><span class="line">This program prints files to the standard output.</span><br><span class="line">Any number of files can be specified.</span><br><span class="line">Options include:</span><br><span class="line">--version : Prints the version number</span><br><span class="line">--help : Display this help'''</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Unknown option.'</span></span><br><span class="line">        sys.exit()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> sys.argv[<span class="number">1</span>:]:</span><br><span class="line">        readfile(filename)</span><br></pre></td></tr></table></figure></p>
<h2 id="os模块">os模块</h2><p>　　使用os.sep可以取代操作系统特定的路径分割符。<br>　　os.name字符串指示你正在使用的平台。比如对于Windows,它是’nt’，而对于Linux/Unix用户，它是’posix’。<br>　　os.getcwd()函数得到当前工作目录，即当前Python脚本工作的目录路径。<br>　　os.getenv()和os.putenv()函数分别用来读取和设置环境变量。<br>　　os.listdir()返回指定目录下的所有文件和目录名。<br>　　os.remove()函数用来删除一个文件。<br>　　os.system()函数用来运行shell命令。<br>　　os.linesep字符串给出当前平台使用的行终止符。例如，Windows使用’\r\n’，Linux使用’\n’而Mac使用’\r’。<br>　　os.path.split()函数返回一个路径的目录名和文件名。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>os.path.split(<span class="string">'/home/swaroop/byte/code/poem.txt'</span>)</span><br><span class="line">(<span class="string">'/home/swaroop/byte/code'</span>, <span class="string">'poem.txt'</span>)</span><br></pre></td></tr></table></figure></p>
<p>　　os.path.isfile()和os.path.isdir()函数分别检验给出的路径是一个文件还是目录。类似地，os.<br>　　path.exists()函数用来检验给出的路径是否真地存在。</p>
<h1 id="更多Python知识">更多Python知识</h1><h2 id="列表综合">列表综合</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: list_comprehension.py</span></span><br><span class="line">listone = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">listtwo = [<span class="number">2</span>*i <span class="keyword">for</span> i <span class="keyword">in</span> listone <span class="keyword">if</span> i &gt; <span class="number">2</span>]</span><br><span class="line"><span class="keyword">print</span> listtwo</span><br></pre></td></tr></table></figure>
<p>　　当要使函数接收元组或字典形式的参数的时候，有一种特殊的方法，它分别使用*和**前缀。这种方法在函数需要获取可变数量的参数的时候特别有用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">powersum</span><span class="params">(power, *args)</span>:</span></span><br><span class="line"><span class="prompt">... </span><span class="string">'''Return the sum of each argument raised to specified power.'''</span></span><br><span class="line"><span class="prompt">... </span>total = <span class="number">0</span></span><br><span class="line"><span class="prompt">... </span><span class="keyword">for</span> i <span class="keyword">in</span> args:</span><br><span class="line">...</span><br><span class="line">total += pow(i, power)</span><br><span class="line"><span class="prompt">... </span><span class="keyword">return</span> total</span><br><span class="line">...</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>powersum(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>powersum(<span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure></p>
<p>　　由于在args变量前有*前缀，所有多余的函数参数都会作为一个元组存储在args中。如果使用的是**前缀，多余的参数则会被认为是一个字典的键/值对。</p>
<h2 id="lamda表达式">lamda表达式</h2><p>　　lambda语句被用来创建新的函数对象，并且在运行时返回它们。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: lambda.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_repeater</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> s: s*n</span><br><span class="line">twice = make_repeater(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">print</span> twice(<span class="string">'word'</span>)</span><br><span class="line"><span class="keyword">print</span> twice(<span class="number">5</span>)</span><br></pre></td></tr></table></figure></p>
<p>　　这里，我们使用了make_repeater函数在运行时创建新的函数对象，并且返回它。lambda语句用来创建函数对象。本质上，lambda需要一个参数，后面仅跟单个表达式作为函数体，而表达式的值被这个新建的函数返回。注意，即便是print语句也不能用在lambda形式中，只能使用表达式。</p>
<h2 id="exec和eval语句">exec和eval语句</h2><p>　　exec语句用来执行储存在字符串或文件中的Python语句。例如，我们可以在运行时生成一个包含Python代码的字符串，然后使用exec语句执行这些语句。eval语句用来计算存储在字符串中的有效Python表达式。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">exec</span> <span class="string">'print "Hello World"'</span></span><br><span class="line">Hello World</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>eval(<span class="string">'2*3'</span>)</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure></p>
<h2 id="assert语句">assert语句</h2><p>　　assert语句用来声明某个条件是真的。例如，如果你非常确信某个你使用的列表中至少有一个元素，而你想要检验这一点，并且在它非真的时候引发一个错误，那么assert语句是应用在这种情形下的理想语句。当assert语句失败的时候，会引发一个AssertionError。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; mylist = ['item']</span><br><span class="line">&gt;&gt;&gt; assert len(mylist) &gt;= 1</span><br><span class="line">&gt;&gt;&gt; mylist.pop()</span><br><span class="line">'item'</span><br><span class="line">&gt;&gt;&gt; assert len(mylist) &gt;= 1</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File "&lt;stdin&gt;", line 1, in ?</span><br><span class="line">AssertionError</span><br></pre></td></tr></table></figure></p>
<h2 id="repr函数">repr函数</h2><p>　　repr函数用来取得对象的规范字符串表示。反引号(也称转换符，键盘左上角esc下面的那个键)可以完成相同的功能。注意，在大多数时候有eval(repr(object)) == object。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>i = []</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>i.append(<span class="string">'item'</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>`i`</span><br><span class="line"><span class="string">"['item']"</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>repr(i)</span><br><span class="line"><span class="string">"['item']"</span></span><br></pre></td></tr></table></figure></p>
<p>[参考资料]</p>
<ol>
<li><a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/" target="_blank" rel="external">简明Python教程</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[前段时间看到v2和segment上有人谈论Django，就去查了一下，原来是基于Python的开源框架，再加上我早就想学习Python了，最近比较闲，正好就开始了Python的学习，最近看了一个比较入门级别的教程，名为：简明Python教程，学习之余就把一些知识点记录了下来以便复习只用。还有，我发现云课堂上的有一个Python视频课就是按照这本教程来讲解的。]]>
    
    </summary>
    
      <category term="Python" scheme="https://ningban.github.io/tags/Python/"/>
    
      <category term="Python" scheme="https://ningban.github.io/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[11]贝叶斯统计正则化]]></title>
    <link href="https://ningban.github.io/2015/01/21/bayesian-statistics-and-regularization/"/>
    <id>https://ningban.github.io/2015/01/21/bayesian-statistics-and-regularization/</id>
    <published>2015-01-21T07:51:52.000Z</published>
    <updated>2015-03-24T07:34:46.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-11-1.jpg" alt="图11-1"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-11-2.jpg" alt="图11-2"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-11-3.jpg" alt="图11-3"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-11-4.jpg" alt="图11-4"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-11-5.jpg" alt="图11-5"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-11-6.jpg" alt="图11-6"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-11-7.jpg" alt="图11-7"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-11-8.jpg" alt="图11-8"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-11-9.jpg" alt="图11-9"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-11-10.jpg" alt="图11-10"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-11-11.jpg" alt="图11-11"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-11-12.jpg" alt="图11-12"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-11-13.jpg" alt="图11-13"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-11-14.jpg" alt="图11-14"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-11-15.jpg" alt="图11-15"></p>
<p>[参考资料]</p>
<ol>
<li><a href="http://v.163.com/movie/2008/1/L/M/M6SGF6VB4_M6SGKG5LM.html" target="_blank" rel="external">斯坦福大学公开课 ：机器学习课程</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[本节首先介绍了贝叶斯统计和规范化；之后简单介绍了在线学习的概念；之后介绍了机器学习算法设计中的问题诊断技巧；之后介绍了两种分析技巧：误差分析与销蚀分析；最后介绍了两种应用机器学习算法的方式与使用。]]>
    
    </summary>
    
      <category term="机器学习" scheme="https://ningban.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Machine Learning" scheme="https://ningban.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[10]特征选择]]></title>
    <link href="https://ningban.github.io/2015/01/18/select-features/"/>
    <id>https://ningban.github.io/2015/01/18/select-features/</id>
    <published>2015-01-18T08:12:56.000Z</published>
    <updated>2015-03-19T06:22:03.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-10-1.jpg" alt="图10-1"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-10-2.jpg" alt="图10-2"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-10-3.jpg" alt="图10-3"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-10-4.jpg" alt="图10-4"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-10-5.jpg" alt="图10-5"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-10-6.jpg" alt="图10-6"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-10-7.jpg" alt="图10-7"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-10-8.jpg" alt="图10-8"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-10-9.jpg" alt="图10-9"></p>
<p>[参考资料]</p>
<ol>
<li><a href="http://v.163.com/movie/2008/1/U/O/M6SGF6VB4_M6SGJURUO.html" target="_blank" rel="external">斯坦福大学公开课 ：机器学习课程</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[本节首先介绍了VC维的概念——该概念能够将关于ERM一般误差的界的结论推广到无限假设类的情形；之后介绍了模型选择问题——具体介绍了交叉验证方法以及几种变形；最后介绍了特征选择问题——具体介绍了两类方法：封装特征选择和过滤特征选择。]]>
    
    </summary>
    
      <category term="机器学习" scheme="https://ningban.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Machine Learning" scheme="https://ningban.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[9]经验风险最小化ERM]]></title>
    <link href="https://ningban.github.io/2015/01/17/ERM/"/>
    <id>https://ningban.github.io/2015/01/17/ERM/</id>
    <published>2015-01-17T07:18:16.000Z</published>
    <updated>2015-03-24T07:33:07.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-9-1.jpg" alt="图9-1"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-9-2.jpg" alt="图9-2"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-9-3.jpg" alt="图9-3"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-9-4.jpg" alt="图9-4"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-9-5.jpg" alt="图9-5"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-9-6.jpg" alt="图9-6"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-9-7.jpg" alt="图9-7"></p>
<p>[参考资料]</p>
<ol>
<li><a href="http://v.163.com/movie/2008/1/F/H/M6SGF6VB4_M6SGJV3FH.html" target="_blank" rel="external">斯坦福大学公开课 ：机器学习课程</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[本节主要介绍了模型选择中的一种常见现象——偏差方差权衡。为了解释该概念，首先介绍了两个重要的引理——联合届引理和Hoeffding不等式，之后定义了两个重要的概念——训练误差和一般误差，并提出了一种简化的机器学习算法模型——经验风险最小化ERM。最后基于这些该你那对ERM结果的理论上界进行了证明，并基于上界分析对偏差方差权衡进行了解释。]]>
    
    </summary>
    
      <category term="机器学习" scheme="https://ningban.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Machine Learning" scheme="https://ningban.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[8]顺序最小优化算法]]></title>
    <link href="https://ningban.github.io/2015/01/16/smo-algorithm/"/>
    <id>https://ningban.github.io/2015/01/16/smo-algorithm/</id>
    <published>2015-01-16T05:52:14.000Z</published>
    <updated>2015-03-24T07:36:28.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-8-1.jpg" alt="图8-1"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-8-2.jpg" alt="图8-2"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-8-3.jpg" alt="图8-3"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-8-4.jpg" alt="图8-4"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-8-5.jpg" alt="图8-5"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-8-6.jpg" alt="图8-6"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-8-7.jpg" alt="图8-7"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-8-8.jpg" alt="图8-8"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-8-9.jpg" alt="图8-9"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-8-10.jpg" alt="图8-10"></p>
<p>[参考资料]</p>
<ol>
<li><a href="http://v.163.com/movie/2008/1/9/3/M6SGF6VB4_M6SGJVA93.html" target="_blank" rel="external">斯坦福大学公开课 ：机器学习课程</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[本节首先介绍了核的概念——它在SVM以及许多学习算法中都有重要的应用，之后介绍了L1 norm软间隔SVM——它使用SVM的变化形式，可以处理非线性可分隔的数据，最后介绍了SMO算法——一种高效的可以解决SVM优化问题的算法。]]>
    
    </summary>
    
      <category term="机器学习" scheme="https://ningban.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Machine Learning" scheme="https://ningban.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[闲中作画]]></title>
    <link href="https://ningban.github.io/2015/01/16/scrawl-in-leisure-time/"/>
    <id>https://ningban.github.io/2015/01/16/scrawl-in-leisure-time/</id>
    <published>2015-01-16T05:44:05.000Z</published>
    <updated>2015-03-08T12:58:29.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7vihec.com1.z0.glb.clouddn.com/yiqiko.png" alt="黑崎一护"></p>
]]></content>
    <summary type="html">
    <![CDATA[一护参上]]>
    
    </summary>
    
      <category term="Life" scheme="https://ningban.github.io/tags/Life/"/>
    
      <category term="Life" scheme="https://ningban.github.io/categories/Life/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[7]最优间隔分类器]]></title>
    <link href="https://ningban.github.io/2015/01/15/optimal-margin-classifier/"/>
    <id>https://ningban.github.io/2015/01/15/optimal-margin-classifier/</id>
    <published>2015-01-15T10:00:03.000Z</published>
    <updated>2015-03-24T07:36:00.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-7-1.jpg" alt="图7-1"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-7-2.jpg" alt="图7-2"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-7-3.jpg" alt="图7-3"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-7-4.jpg" alt="图7-4"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-7-5.jpg" alt="图7-5"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-7-6.jpg" alt="图7-6"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-7-7.jpg" alt="图7-7"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-7-8.jpg" alt="图7-8"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-7-9.jpg" alt="图7-9"></p>
<p>[参考资料]</p>
<ol>
<li><a href="http://v.163.com/movie/2008/1/C/6/M6SGF6VB4_M6SGJVMC6.html" target="_blank" rel="external">斯坦福大学公开课 ：机器学习课程</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[本节首先提出了原始的最优化问题：最优间隔分类器问题，之后介绍了对偶问题的概念和KKT条件，之后基于原始优化问题的对偶问题的分析，介绍了SVM算法。课程的最后对SVM算法进行了评价，以引出下节课对核方法的介绍。]]>
    
    </summary>
    
      <category term="机器学习" scheme="https://ningban.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Machine Learning" scheme="https://ningban.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[打发悲伤的涂鸦]]></title>
    <link href="https://ningban.github.io/2015/01/15/scrawl-to-release-sad/"/>
    <id>https://ningban.github.io/2015/01/15/scrawl-to-release-sad/</id>
    <published>2015-01-15T09:31:31.000Z</published>
    <updated>2015-03-08T13:01:06.000Z</updated>
    <content type="html"><![CDATA[<p>　　人生不如意十有八九，最近我不小心误入八九之中，现在终于出来了。虽然我们都挺讨厌八九的，但是我挺感谢它的，因为它让我领悟到了“命中注定”（失败者的托词），领悟到了“行百里者半九十”，领悟到了“好了伤疤忘了疼”，领悟到了“书读太少，想太多”，领悟到了“受尽苦难而不厌，此乃修罗之道”。来，看下阴转悲伤的天气：<br><img src="http://7vihec.com1.z0.glb.clouddn.com/sad.png" alt="阴转sadness的心情"></p>
]]></content>
    <summary type="html">
    <![CDATA[命运（日语叫unmei）、行百里者半九十]]>
    
    </summary>
    
      <category term="Life" scheme="https://ningban.github.io/tags/Life/"/>
    
      <category term="Life" scheme="https://ningban.github.io/categories/Life/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[6]朴素贝叶斯算法]]></title>
    <link href="https://ningban.github.io/2015/01/12/naive-bayes-algorithm/"/>
    <id>https://ningban.github.io/2015/01/12/naive-bayes-algorithm/</id>
    <published>2015-01-12T12:17:50.000Z</published>
    <updated>2015-03-24T07:35:37.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-6-1.jpg" alt="图6-1"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-6-2.jpg" alt="图6-2"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-6-3.jpg" alt="图6-3"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-6-4.jpg" alt="图6-4"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-6-5.jpg" alt="图6-5"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-6-6.jpg" alt="图6-6"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-6-7.jpg" alt="图6-7"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-6-8.jpg" alt="图6-8"></p>
<p>[参考资料]</p>
<ol>
<li><a href="http://v.163.com/movie/2008/1/7/H/M6SGF6VB4_M6SGJVV7H.html" target="_blank" rel="external">斯坦福大学公开课 ：机器学习课程</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[本节首先介绍了两种朴素贝叶斯算法的时间模型，之后介绍了神经网络算法，并在最后介绍了两个重要的概念：函数间隔和几何间隔，基于这两个概念提出了一个线性分类算法：最大间隔分类器算法。该算法用于引出一个非常重要的非线性分类算法：支持向量机SVM。]]>
    
    </summary>
    
      <category term="机器学习" scheme="https://ningban.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Machine Learning" scheme="https://ningban.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[5]生成学习算法]]></title>
    <link href="https://ningban.github.io/2015/01/11/generate-learning-algorithm/"/>
    <id>https://ningban.github.io/2015/01/11/generate-learning-algorithm/</id>
    <published>2015-01-11T10:43:31.000Z</published>
    <updated>2015-03-24T07:35:12.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-5-1.jpg" alt="图5-1"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-5-2.jpg" alt="图5-2"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-5-3.jpg" alt="图5-3"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-5-4.jpg" alt="图5-4"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-5-5.jpg" alt="图5-5"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-5-6.jpg" alt="图5-6"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-5-7.jpg" alt="图5-7"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-5-8.jpg" alt="图5-8"></p>
<p>[参考资料]</p>
<ol>
<li><a href="http://v.163.com/movie/2008/1/A/R/M6SGF6VB4_M6SGHMFAR.html" target="_blank" rel="external">斯坦福大学公开课 ：机器学习课程</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[本课首先介绍了一类新的学习算法——生成学习算法，并详细介绍了该算法的一个例子：高斯判别分析；之后对生成学习算法与之前的判别学习算法进行对比；最后介绍了一个合适对文本进行分类的算法——朴素贝叶斯算法，并结合该算法介绍了一种常用的平滑技术——Lapace平滑。]]>
    
    </summary>
    
      <category term="机器学习" scheme="https://ningban.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Machine Learning" scheme="https://ningban.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[洋为中用]]></title>
    <link href="https://ningban.github.io/2015/01/10/adapt-foeign-things-for-Chinese-use/"/>
    <id>https://ningban.github.io/2015/01/10/adapt-foeign-things-for-Chinese-use/</id>
    <published>2015-01-10T03:49:16.000Z</published>
    <updated>2015-03-08T12:53:07.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7vihec.com1.z0.glb.clouddn.com/thinking.jpeg" alt="浩瀚的宇宙"><br>　　昨天老师关于论文开了一个会，会上的一句话令我颇为震撼。“不管是做学术还是其他，老外基本上总是走在最前方，国内都是copy其思想或者模式，继而找到适合中国特色的道路。如百度与Google，阿里巴巴与亚马逊等。同样，在学术方面基本也是如此，所以要习惯看英文文章，这样才可以接触最前沿的东西。”其实却是是这样，现在国内的互联网公司的模式大多是都是从国外借鉴过来的，比如最近的打车应用就是师从Uber，在线教育就是师从Coursera。我对老师的话语产生共鸣的原因有二：一是我虽然也有同样的想法，但是我从来没有像他这样总结成章，所以平常的我缺乏思考（ps：学而不思则罔，思而不学则殆）；二，即使我也像老师那样总结成章，但我也不会把这套理论应用于学术方面，所以平常的我思维不够发散与活跃，不懂得举一反三。<br>　　在会上，当我提到Stanford的机器学习视频的时候，老师也赞同现在的在线教育之火热，并且建议我们到<a href="http://www.mooc.cn/" target="_blank" rel="external">MOOC</a>上去学习。MOOC这个课程网站之前我再<a href="https://www.v2ex.com/?r=Jning" target="_blank" rel="external">v2ex</a>上看到过，知道它是一个公开课平台，这次之后特地查了一下，确实不错，有很多国内外名校的课程都放在了上面，我们可以自行去学习，以后我也会经常去逛一逛。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7vihec.com1.z0.glb.clouddn.com/thinking.jpeg" alt="浩瀚的宇宙"><br>　　昨天老师关于论文开了一个会，会上的一句话令我颇为震撼。“不管是做学术还是其他，老外基本上总是走在最前方，国内都是]]>
    </summary>
    
      <category term="分享与发现" scheme="https://ningban.github.io/tags/%E5%88%86%E4%BA%AB%E4%B8%8E%E5%8F%91%E7%8E%B0/"/>
    
      <category term="分享与发现" scheme="https://ningban.github.io/categories/%E5%88%86%E4%BA%AB%E4%B8%8E%E5%8F%91%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[4]牛顿方法]]></title>
    <link href="https://ningban.github.io/2015/01/09/Newtown-methods/"/>
    <id>https://ningban.github.io/2015/01/09/Newtown-methods/</id>
    <published>2015-01-09T05:23:56.000Z</published>
    <updated>2015-03-24T07:33:49.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-4-1.png" alt="图4-1"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-4-2.jpg" alt="图4-2"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-4-3.jpg" alt="图4-3"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-4-4.jpg" alt="图4-4"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-4-5.jpg" alt="图4-5"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-4-6.jpg" alt="图4-6"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-4-7.jpg" alt="图4-7"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-4-8.jpg" alt="图4-8"></p>
<p>[参考资料]</p>
<ol>
<li><a href="http://v.163.com/movie/2008/1/E/D/M6SGF6VB4_M6SGHKAED.html" target="_blank" rel="external">斯坦福大学公开课 ：机器学习课程</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[本节首先介绍了牛顿方法，可以替代梯度上升算法用来计算函数的最大值；之后以高斯分布和伯努利分布为例介绍了指数分布函数族；最后一指数分布函数族作为基础，引出了广义线性模型，可以通过指定概率分布直接推导出模型。]]>
    
    </summary>
    
      <category term="机器学习" scheme="https://ningban.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Machine Learning" scheme="https://ningban.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[3]欠拟合与过拟合]]></title>
    <link href="https://ningban.github.io/2015/01/08/underfit-and-overfit/"/>
    <id>https://ningban.github.io/2015/01/08/underfit-and-overfit/</id>
    <published>2015-01-08T12:12:45.000Z</published>
    <updated>2015-03-24T07:36:54.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-3-1.jpg" alt="图3-1"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-3-2.jpg" alt="图3-2"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-3-3.jpg" alt="图3-3"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-3-4.jpg" alt="图3-4"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-3-5.jpg" alt="图3-5"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-3-6.jpg" alt="图3-6"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-3-7.jpg" alt="图3-7"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-3-8.jpg" alt="图3-8"></p>
<p>[参考资料]</p>
<ol>
<li><a href="http://v.163.com/movie/2008/1/E/B/M6SGF6VB4_M6SGHM4EB.html" target="_blank" rel="external">斯坦福大学公开课 ：机器学习课程</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[欠拟合与过拟合的概念，参数化即非参数化算法概念，局部加权回归，对于线性模型的概率解释，Logistic回归，感知器...]]>
    
    </summary>
    
      <category term="机器学习" scheme="https://ningban.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Machine Learning" scheme="https://ningban.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[2]监督学习应用.梯度下降]]></title>
    <link href="https://ningban.github.io/2015/01/08/Gradient-Descent-algorithm/"/>
    <id>https://ningban.github.io/2015/01/08/Gradient-Descent-algorithm/</id>
    <published>2015-01-08T05:23:54.000Z</published>
    <updated>2015-03-24T07:01:38.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-2-1.jpg" alt="图2-1"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-2-2.jpg" alt="图2-2"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-2-3.jpg" alt="图2-3"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-2-4.jpg" alt="图2-4"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-2-5.jpg" alt="图2-5"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-2-6.jpg" alt="图2-6"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-2-7.jpg" alt="图2-7"></p>
<p>[参考资料]</p>
<ol>
<li><a href="http://v.163.com/movie/2008/1/B/O/M6SGF6VB4_M6SGHJ9BO.html" target="_blank" rel="external">斯坦福大学公开课 ：机器学习课程</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[监督学习应用——自助推导，ALVNN系统，线性回归，梯度下降，批梯度下降，随机梯度下降...]]>
    
    </summary>
    
      <category term="机器学习" scheme="https://ningban.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Machine Learning" scheme="https://ningban.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[随笔于20150108]]></title>
    <link href="https://ningban.github.io/2015/01/08/informal-essay-in-20150108/"/>
    <id>https://ningban.github.io/2015/01/08/informal-essay-in-20150108/</id>
    <published>2015-01-08T04:28:58.000Z</published>
    <updated>2015-01-10T04:16:33.000Z</updated>
    <content type="html"><![CDATA[<p>　　好久没有写博客了，有几方面的原因：首先，就是自己没有坚持写博客，也就是自己毅力不给力啊；然后，就是最近有点别的事情在忙，当然既有正事也有玩的事情。<br>　　一晃一年就这样过去了，好快（ps：日语叫做哈压抑）啊！看到很多人都在写自己的2014年终总结，还有2015年计划，自己也有点小激动，虽然一年也没有什么作为，但是还是写了，只不过是没有公开。昨天练完车回来之后，突然意识到我好久没有写什么东西了，但是又没有什么可以写的，就开始看Stanford的机器学习教学视频，这个视频讲的非常好，虽然我也没听太懂，也是云里雾里的，但是还在坚持看。视频里的老师就是上一年加入百度的牛人Andrew NG，现在加入百度，负责“百度大脑”，以前在google，同时他也是在线教育Coursera的创始人哦。他不仅学术做的好，课讲的也相当不错哦，所以视频相当值得一看！在看视频的过程中，当然我也做了一些笔记（ps:所谓的笔记，也不过是把他写在黑板上的东西copy了一遍而已），于是乎，我就想我过年回家的是时候怎么看我做过的笔记啊，难道要把note拿回家，估计拿了也不会看吧。所以，我就想是不是可以把这些笔记拍成照片放在我的博客里呢，这样的话，只要有网络我就可以看看笔记了，于是我就来这里瞎写来了。对于我学习机器学习的原因呢，大约有这几个原因：首先，这不，快要毕业了嘛，论文是关于机器学习的，所以就开始学习机器学习喽；其次呢，就是我曾经发表过一篇关于信息抽取的文章（ps：很水的文章啦，无视吧），里面用到机器学习的算法，所以我想再更深入的了解一下机器学习，说不定未来的工作会用到机器学习，或者自己一下子会喜欢上了这个高大上的方向呢。好了，废话就不说太多了，接下来的n多篇文章应该都是视频里的笔记，我可能会在看完这个视频之后，还是看一下加州理工的机器学习视频，笔记也会一并发布在这里吧。他们都是网易公开课里面的视频，我会把视频链接地址写在接下来的参考文献里面。</p>
<p>[参考资料]</p>
<ol>
<li><a href="http://v.163.com/special/opencourse/machinelearning.html" target="_blank" rel="external">斯坦福大学公开课 ：机器学习课程</a></li>
<li><a href="http://v.163.com/special/opencourse/learningfromdata.html9" target="_blank" rel="external">加州理工学院公开课：机器学习与数据挖掘</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　好久没有写博客了，有几方面的原因：首先，就是自己没有坚持写博客，也就是自己毅力不给力啊；然后，就是最近有点别的事情在忙，当然既有正事也有玩的事情。<br>　　一晃一年就这样过去了，好快（ps：日语叫做哈压抑）啊！看到很多人都在写自己的2014年终总结，还有2015年计划]]>
    </summary>
    
      <category term="机器学习" scheme="https://ningban.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Machine Learning" scheme="https://ningban.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
</feed>