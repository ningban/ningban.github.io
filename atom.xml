<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[JNing+]]></title>
  <subtitle><![CDATA[Stay hungry, Stay foolish...]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="https://ningban.github.io/"/>
  <updated>2015-03-23T03:24:40.000Z</updated>
  <id>https://ningban.github.io/</id>
  
  <author>
    <name><![CDATA[JNing]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[决策树算法之ID3算法]]></title>
    <link href="https://ningban.github.io/2015/03/20/ID3-algorithm/"/>
    <id>https://ningban.github.io/2015/03/20/ID3-algorithm/</id>
    <published>2015-03-20T12:58:47.000Z</published>
    <updated>2015-03-23T03:24:40.000Z</updated>
    <content type="html"><![CDATA[<h1 id="决策树引论">决策树引论</h1><p>　　如果你以前没有接触过决策树，完全不用担心，它的概念非常简单。即使不知道它也可以通过简单的图像了解其工作原理，图3-1所示的流程图就是一个决策树，正方形代表判断模块，椭圆形代表终止模块，表示已经得出结论，可以终止运行。从判断模块引出的左右箭头称作分支，它可以到达量一个判断模块或者终止模块。图3-1构造了一个假想的邮件分类系统，它首先检测发送邮件域名地址。如果地址位myEmployer.com，则将其放在分类“无聊时需要阅读的邮件”中。如果邮件不是来自这个域名，则检查邮件内容里是否包含单词曲棍球，如果包含则将邮件归类到“需要即使处理的朋友邮件”，如果不包含则将邮件归类到“无序阅读的垃圾邮件”。<br><img src="http://7vihec.com1.z0.glb.clouddn.com/mlp-decisionImg.jpg" alt="原书 图3-1"></p>
<h1 id="决策树的构造">决策树的构造</h1><p>　　在构造决策树时，我们需要解决的第一个问题就是，当前数据集上哪些特征在划分数据分类时其决定性作用。为了找到决定性的特征，划分出最好的结果，我们必须评估每个特征。完成测试之后，原始数据集就被划分为几个数据子集。这些数据子集会分布在第一个决策点的所有分支上。如果某个分支下的数据属于同一个类型，则当前无需阅读的垃圾邮件已经正确地划分数据分类，无序进一步对数据集进行分割。如果数据子集内的数据不属于同一类型，则需要重复划分数据子集的过程。如果划分数据子集的算法和划分原始数据集的方法相同，知道所有具有相同类型的数据均在一个数据子集内。</p>
<h2 id="决策树的一般流程">决策树的一般流程</h2><p>　　1. 收集数据：可以使用任何方法；<br>　　2. 准备数据：树构造算法只适用于标称型数据，因此数值型数据必须离散化；<br>　　3. 分析数据：可以使用任何方法，构造树完成之后，我们应该检查图形是否符合预期；<br>　　4. 训练算法：构造树的数据结构；<br>　　5. 测试算法：使用经验树计算错误率；<br>　　6. 使用算法：此步骤可以适用于任何监督学习算法，而使用决策树可以更好地理解数据的内在含义。</p>
<h2 id="信息增益的概念">信息增益的概念</h2><p>　　划分数据集的最大原则是：将无序的数据变得更加有序。组织杂乱无章数据的一种方法就是使用信息论度量信息。在划分数据集之前之后信息发生的变化称为<code>信息增益</code>。知道如何计算信息增益，我们就可以计算每个特征值划分数据集获得的信息增益，获得信息增益最高的特征就是最好的选择。<br>　　载可以评测哪种数据划分方式是最好的数据划分之前，我们必须学习如何计算信息增益。集合信息的度量方式称为香农熵或者简称熵，这个名字来源于信息论支付克劳德-香农。<br>　　<code>熵</code>定义为信息的期望，熵越高，则混合的数据的种类也越多，在明晰信息增益这个概念之前，我们必须知道信息的定义。如果待分类的事物可能划分在多个分类之中，则符号$x_i$的<code>信息</code>定义为：<br>$$l(x_i) = -log_2 p(x_i)$$<br>　　其中$p(x_i)$是选择该分类的概率。<br>　　为了计算熵，我们需要计算所有类别所有可能值包含的信息期望值，通过下面的公式得到：<br>$$H = -\sum_{i=1}^n p(x_i)log_2 p(x_i)$$<br>　　其中n是分类的数目。</p>
<h2 id="划分数据集">划分数据集</h2><p>　　上面我们学习了如何度量数据集的无序程度，分类算法除了需要测量信息熵，还需要划分数据集，度量划分数据集的熵，以便判断当前是否正确地划分了数据集。我们将对每个特征划分数据集的结果计算一次信息熵，然后判断按照哪个特征划分数据及使最好的划分方式。</p>
<h2 id="递归构建决策树">递归构建决策树</h2><p>　　目前我们已经学习了从数据集构造决策树算法所需要的子功能模块，其工作原理如下：得到原始数据集，然后基于最好的属性值划分数据集，由于特征值可能多于两个，因此可能存在大于两个分支的数据集划分。第一次划分之后，数据将被传递到树分支的下一个节点，在这个节点上，我们可以再次划分数据。因此我们可以采用递归的原则处理数据集。<br>　　递归结束的条件是：程序遍历完所有划分数据集的属性，或者每个分支下的所有实例都具有相同的分类。如果数据集已经处理了所有属性，但是类标签依然不是唯一的，此时我们需要决定如何定义该叶子节点，载这种情况下，我们通常采用多数表决的方法决定该叶子节点的分类。</p>
<h2 id="决策树代码实现">决策树代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#Filename: trees.py</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：创建数据集</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createDataSet</span><span class="params">()</span>:</span></span><br><span class="line">  dataSet = [[<span class="number">1</span>, <span class="number">1</span>, <span class="string">'yes'</span>], </span><br><span class="line">		[<span class="number">1</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</span><br><span class="line">		[<span class="number">1</span>, <span class="number">0</span>, <span class="string">'no'</span>],</span><br><span class="line">		[<span class="number">0</span>, <span class="number">1</span>, <span class="string">'no'</span>],</span><br><span class="line">		[<span class="number">0</span>, <span class="number">1</span>, <span class="string">'no'</span>]]</span><br><span class="line">  labels = [<span class="string">'no surfacing'</span>, <span class="string">'flippers'</span>]</span><br><span class="line">  <span class="keyword">return</span> dataSet, labels</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：计算给定数据集的香农熵</span></span><br><span class="line"><span class="comment">#param：</span></span><br><span class="line"><span class="comment">#	dataset ==&gt; 数据集</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcShannonEnt</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">  numEntries = len(dataSet)</span><br><span class="line">  labelCounts = &#123;&#125;</span><br><span class="line">  <span class="comment">#为所有可能的分类创建字典，key中存放的是类别，value中存储的是属于该类别的个数</span></span><br><span class="line">  <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:</span><br><span class="line">  	currentLabel = featVec[-<span class="number">1</span>]</span><br><span class="line">  	<span class="keyword">if</span> currentLabel <span class="keyword">not</span> <span class="keyword">in</span> labelCounts.keys():</span><br><span class="line">  		labelCounts[currentLabel] = <span class="number">0</span></span><br><span class="line">  	labelCounts[currentLabel] += <span class="number">1</span></span><br><span class="line">  shannonEnt = <span class="number">0.0</span></span><br><span class="line">  <span class="comment">#计算香农熵</span></span><br><span class="line">  <span class="keyword">for</span> key <span class="keyword">in</span> labelCounts:</span><br><span class="line">  	prob = float(labelCounts[key])/numEntries</span><br><span class="line">  	shannonEnt -= prob * log(prob, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">return</span> shannonEnt</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：按照给定特征划分数据集</span></span><br><span class="line"><span class="comment">#param：</span></span><br><span class="line"><span class="comment">#	dataSet ==&gt; 数据集</span></span><br><span class="line"><span class="comment">#	axis       ==&gt; 特征列下标</span></span><br><span class="line"><span class="comment">#	value    ==&gt; 属性值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">splitDataSet</span><span class="params">(dataSet, axis, value)</span>:</span></span><br><span class="line">  retDataSet = []</span><br><span class="line">  <span class="comment">#抽取出axis特征列属性值为value的列表</span></span><br><span class="line">  <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:</span><br><span class="line">  	<span class="keyword">if</span> featVec[axis] == value:</span><br><span class="line">  		reducedFeatVec = featVec[:axis]</span><br><span class="line">  		reducedFeatVec.extend(featVec[axis+<span class="number">1</span>:])</span><br><span class="line">  		retDataSet.append(reducedFeatVec)</span><br><span class="line">  <span class="keyword">return</span> retDataSet</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：选择最好的数据集划分方式</span></span><br><span class="line"><span class="comment">#param：</span></span><br><span class="line"><span class="comment">#	dataSet ==&gt; 数据集</span></span><br><span class="line"><span class="comment">#在函数中调用的数据需要满足一定的要求：</span></span><br><span class="line"><span class="comment">#	1. 数据必须是一种由列表元素组成的列表，而且所有的列表元素都要具有相同的数据长度；</span></span><br><span class="line"><span class="comment">#	2. 数据的最后一列或者每个实例的最后一个元素是当前实例的类标签。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chooseBestFeatureToSplit</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">  numFeatures = len(dataSet[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">  baseEntropy = calcShannonEnt(dataSet)</span><br><span class="line">  bestInfoGain = <span class="number">0.0</span></span><br><span class="line">  bestFeature = -<span class="number">1</span></span><br><span class="line">  <span class="comment">#遍历每个特征</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(numFeatures):</span><br><span class="line">  	<span class="comment">#获得i列特征的所有属性值</span></span><br><span class="line">  	featList = [example[i] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">  	uniqueVals = set(featList)</span><br><span class="line">  	newEntropy = <span class="number">0.0</span></span><br><span class="line">  	<span class="comment">#计算每种划分方式的信息熵</span></span><br><span class="line">  	<span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</span><br><span class="line">  		subDataSet = splitDataSet(dataSet, i, value)</span><br><span class="line">  		prob = len(subDataSet)/float(len(dataSet))</span><br><span class="line">  		newEntropy += prob * calcShannonEnt(subDataSet)</span><br><span class="line">  	infoGain = baseEntropy - newEntropy</span><br><span class="line">  	<span class="comment">#选择信息增益最大的作为最佳特征</span></span><br><span class="line">  	<span class="keyword">if</span>(infoGain &gt; bestInfoGain):</span><br><span class="line">  		bestInfoGain = infoGain</span><br><span class="line">  		bestFeature = i</span><br><span class="line">  <span class="keyword">return</span> bestFeature</span><br><span class="line"></span><br><span class="line">  <span class="comment">#Function：如果数据已经处理了所有属性，但是类标签依然不是唯一的，此时我们需要决定如何定义该叶子节点，</span></span><br><span class="line">  <span class="comment">#		在这种情况下，我们通常会采用多数表决的方法决定该叶子节点的分类</span></span><br><span class="line">  <span class="comment">#param：</span></span><br><span class="line">  <span class="comment">#	classList ==&gt; 类别列表</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityCnt</span><span class="params">(classList)</span>:</span></span><br><span class="line">  <span class="comment">#创建字典，key值存储类别属性值，value存放该属性值的个数</span></span><br><span class="line">  classCount = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> vote <span class="keyword">in</span> classList:</span><br><span class="line">  	<span class="keyword">if</span> vote <span class="keyword">not</span> <span class="keyword">in</span> classCount.keys():</span><br><span class="line">  		classCount[vote] = <span class="number">0</span></span><br><span class="line">  	classCount[vote] += <span class="number">1</span></span><br><span class="line">  <span class="comment"># 按照属性值的个数，从大到小排序</span></span><br><span class="line">  sortedClassCount = sorted(classCount.iteritems(),</span><br><span class="line">  	key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="keyword">True</span>)</span><br><span class="line">  <span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：创建树的函数代码</span></span><br><span class="line"><span class="comment">#param：</span></span><br><span class="line"><span class="comment">#	dataSet ==&gt; 数据集</span></span><br><span class="line"><span class="comment">#	labels    ==&gt; 特征列名称</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createTree</span><span class="params">(dataSet, labels)</span>:</span></span><br><span class="line">  <span class="comment">#类别列表</span></span><br><span class="line">  classList = [example[-<span class="number">1</span>] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">  <span class="comment">#若类别完全相同，则停止继续划分，并返回类别</span></span><br><span class="line">  <span class="keyword">if</span> classList.count(classList[<span class="number">0</span>]) == len(classList):</span><br><span class="line">  	<span class="keyword">return</span> classList[<span class="number">0</span>]</span><br><span class="line">  <span class="comment">#若遍历完所有特征时，但类别依然不唯一，则返回出现次数最多的类别</span></span><br><span class="line">  <span class="keyword">if</span> len(dataSet[<span class="number">0</span>]) == <span class="number">1</span>:</span><br><span class="line">  	<span class="keyword">return</span> majorityCnt(classList)</span><br><span class="line">  <span class="comment">#选择最佳的特征的下标</span></span><br><span class="line">  bestFeat = chooseBestFeatureToSplit(dataSet)</span><br><span class="line">  <span class="comment">#获得最佳的特征名称</span></span><br><span class="line">  bestFeatLabel = labels[bestFeat]</span><br><span class="line">  <span class="comment">#字典变量myTree，存储了树的所有信息</span></span><br><span class="line">  myTree = &#123;bestFeatLabel:&#123;&#125;&#125;</span><br><span class="line">  <span class="keyword">del</span>(labels[bestFeat])</span><br><span class="line">  <span class="comment">#得到最佳特征列包含的所有值</span></span><br><span class="line">  featValues = [example[bestFeat] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">  uniqueVals = set(featValues)</span><br><span class="line">  <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</span><br><span class="line">  	subLabels = labels[:]</span><br><span class="line">  	<span class="comment">#划分数据集</span></span><br><span class="line">  	tmpDataSet = splitDataSet(dataSet, bestFeat, value)</span><br><span class="line">  	<span class="comment">#创建树结构</span></span><br><span class="line">  	myTree[bestFeatLabel][value] = createTree(tmpDataSet, subLabels)</span><br><span class="line">  <span class="keyword">return</span> myTree</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：使用决策树的分类函数</span></span><br><span class="line"><span class="comment">#param：</span></span><br><span class="line"><span class="comment">#	inputTree：字典树</span></span><br><span class="line"><span class="comment">#	featLabels：标签，或者叫做列的名称</span></span><br><span class="line"><span class="comment">#	testVec：     测试向量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classify</span><span class="params">(inputTree, featLabels, testVec)</span>:</span></span><br><span class="line">  firstStr = inputTree.keys()[<span class="number">0</span>]</span><br><span class="line">  secondDict = inputTree[firstStr]</span><br><span class="line">  featIndex = featLabels.index(firstStr) <span class="comment">#将标签字符串转换为索引</span></span><br><span class="line">  <span class="keyword">if</span> type(secondDict).__name__ != <span class="string">'dict'</span>:</span><br><span class="line">  	<span class="keyword">return</span> secondDict</span><br><span class="line">  <span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():</span><br><span class="line">  	<span class="keyword">if</span> testVec[featIndex] == key:</span><br><span class="line">  		<span class="keyword">if</span> type(secondDict[key]).__name__ == <span class="string">'dict'</span>:</span><br><span class="line">  			classLabel = classify(secondDict[key], featLabels, testVec)</span><br><span class="line">  		<span class="keyword">else</span>:</span><br><span class="line">  			classLabel = secondDict[key]</span><br><span class="line">  <span class="keyword">return</span> classLabel</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：使用pickle模块存储决策树</span></span><br><span class="line"><span class="comment">#param：</span></span><br><span class="line"><span class="comment">#	inputTree ==&gt; 决策树</span></span><br><span class="line"><span class="comment">#	filename  ==&gt; 文件名</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">storeTree</span><span class="params">(inputTree, filename)</span>:</span></span><br><span class="line">  <span class="keyword">import</span> pickle</span><br><span class="line">  fw = open(filename, <span class="string">'w'</span>)</span><br><span class="line">  pickle.dump(inputTree, fw)</span><br><span class="line">  fw.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：使用pickle模块获取存储的决策树</span></span><br><span class="line"><span class="comment">#param：</span></span><br><span class="line"><span class="comment">#	filename ==&gt; 文件名</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grabTree</span><span class="params">(filename)</span>:</span></span><br><span class="line">  <span class="keyword">import</span> pickle</span><br><span class="line">  fr = open(filename)</span><br><span class="line">  <span class="keyword">return</span> pickle.load(fr)</span><br></pre></td></tr></table></figure>
<h2 id="决策树画图展示">决策树画图展示</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#-*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="comment">#FileName: treePlotter.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment">#定义数树节点格式的常量</span></span><br><span class="line"><span class="comment">#boxystle控制节点的边框样式，fc控制节点的背景色</span></span><br><span class="line">decisionNode = dict(boxstyle=<span class="string">'sawtooth'</span>, fc=<span class="string">'0.8'</span>)</span><br><span class="line">leafNode = dict(boxstyle=<span class="string">'round4'</span>, fc=<span class="string">'0.8'</span>)</span><br><span class="line">arrow_args = dict(arrowstyle=<span class="string">'&lt;-'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：画节点</span></span><br><span class="line"><span class="comment">#param：</span></span><br><span class="line"><span class="comment">#	nodeTxt    ==&gt; 节点的文本</span></span><br><span class="line"><span class="comment">#	centerPt    ==&gt; 节点正中心的坐标</span></span><br><span class="line"><span class="comment">#	parentPt    ==&gt; 指向节点的点的坐标</span></span><br><span class="line"><span class="comment">#	nodeType  ==&gt; 指向节点的点的样式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotNode</span><span class="params">(nodeTxt, centerPt, parentPt, nodeType)</span>:</span></span><br><span class="line">  createPlot.axl.annotate(nodeTxt, xy=parentPt, xycoords=<span class="string">'axes fraction'</span>,</span><br><span class="line">  	xytext=centerPt, textcoords=<span class="string">'axes fraction'</span>, va=<span class="string">'center'</span>, ha =<span class="string">'center'</span>, </span><br><span class="line">  	bbox=nodeType, arrowprops=arrow_args)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：画图</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createPlot</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="comment">#创建新图形</span></span><br><span class="line">  fig = plt.figure(<span class="number">1</span>, facecolor=<span class="string">'white'</span>) <span class="comment">#facecolor为图像的背景色</span></span><br><span class="line">  fig.clf() <span class="comment">#清空绘图区clf（clear figure）</span></span><br><span class="line">  createPlot.axl = plt.subplot(<span class="number">111</span>, frameon=<span class="keyword">False</span>)</span><br><span class="line">  plotNode(<span class="string">'a decision node'</span>, (<span class="number">0.5</span>, <span class="number">0.1</span>), (<span class="number">0.1</span>, <span class="number">0.5</span>), decisionNode)</span><br><span class="line">  plotNode(<span class="string">'a leaf node'</span>, (<span class="number">0.8</span>, <span class="number">0.1</span>), (<span class="number">0.3</span>, <span class="number">0.8</span>), leafNode)</span><br><span class="line">  plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：获取叶节点的数目</span></span><br><span class="line"><span class="comment">#param:</span></span><br><span class="line"><span class="comment">#	myTree ==&gt; 字典树</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getNumLeafs</span><span class="params">(myTree)</span>:</span></span><br><span class="line">  numLeafs = <span class="number">0</span></span><br><span class="line">  firstStr = myTree.keys()[<span class="number">0</span>]</span><br><span class="line">  secondDict = myTree[firstStr]</span><br><span class="line">  <span class="keyword">if</span> type(secondDict).__name__ != <span class="string">'dict'</span>:</span><br><span class="line">  	numLeafs += <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">  	<span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():</span><br><span class="line">  		<span class="keyword">if</span> type(secondDict[key]).__name__ == <span class="string">'dict'</span>:</span><br><span class="line">  			numLeafs += getNumLeafs(secondDict[key])</span><br><span class="line">  		<span class="keyword">else</span>:</span><br><span class="line">  			numLeafs += <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> numLeafs</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：获取树的高度</span></span><br><span class="line"><span class="comment">#param：</span></span><br><span class="line"><span class="comment">#	myTree ==&gt; 字典树</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTreeDepth</span><span class="params">(myTree)</span>:</span></span><br><span class="line">  maxDepth = <span class="number">0</span></span><br><span class="line">  firstStr = myTree.keys()[<span class="number">0</span>]</span><br><span class="line">  secondDict = myTree[firstStr]</span><br><span class="line">  <span class="keyword">if</span> type(secondDict).__name__ != <span class="string">'dict'</span>:</span><br><span class="line">  	thisDepth = <span class="number">0</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">  	<span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():</span><br><span class="line">  		<span class="keyword">if</span> type(secondDict[key]).__name__ == <span class="string">'dict'</span>:</span><br><span class="line">  			thisDepth = <span class="number">1</span> + getTreeDepth(secondDict[key])</span><br><span class="line">  		<span class="keyword">else</span>:</span><br><span class="line">  			thisDepth = <span class="number">1</span></span><br><span class="line">  		<span class="keyword">if</span> thisDepth &gt; maxDepth:</span><br><span class="line">  			maxDepth = thisDepth</span><br><span class="line">  <span class="keyword">return</span> maxDepth</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：存储树的信息，避免了每次测试代码时都要从数据中创建树的麻烦</span></span><br><span class="line"><span class="comment">#param：</span></span><br><span class="line"><span class="comment">#	i ==&gt; 下标索引</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">retrieveTree</span><span class="params">(i)</span>:</span></span><br><span class="line">  listOfTrees = [&#123;<span class="string">'no surfacing'</span>: &#123;<span class="number">0</span>: <span class="string">'no'</span>, <span class="number">1</span>: &#123;<span class="string">'flippers'</span>: \</span><br><span class="line">  		&#123;<span class="number">0</span>: <span class="string">'no'</span>, <span class="number">1</span>: <span class="string">'yes'</span>&#125;&#125;&#125;&#125;,</span><br><span class="line">  	            &#123;<span class="string">'no surfacing'</span>: &#123;<span class="number">0</span>: <span class="string">'no'</span>, <span class="number">1</span>: &#123;<span class="string">'flippers'</span>: \</span><br><span class="line">  		&#123;<span class="number">0</span>: &#123;<span class="string">'head'</span>: &#123;<span class="number">0</span>: <span class="string">'no'</span>, <span class="number">1</span>: <span class="string">'yes'</span>&#125;&#125;, <span class="number">1</span>: <span class="string">'no'</span>&#125;&#125;&#125;&#125;</span><br><span class="line">  		]</span><br><span class="line">  <span class="keyword">return</span> listOfTrees[i]</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：画出父子节点间填充的文本信息</span></span><br><span class="line"><span class="comment">#param：</span></span><br><span class="line"><span class="comment">#	cntrPt        ==&gt; 子节点坐标</span></span><br><span class="line"><span class="comment">#	parentPt   ==&gt; 父节点坐标</span></span><br><span class="line"><span class="comment">#	txtString    ==&gt; 填充的文字</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotMidText</span><span class="params">(cntrPt, parentPt, txtString)</span>:</span></span><br><span class="line">  xMid = (parentPt[<span class="number">0</span>] - cntrPt[<span class="number">0</span>])/<span class="number">2.0</span> + cntrPt[<span class="number">0</span>]</span><br><span class="line">  yMid = (parentPt[<span class="number">1</span>] - cntrPt[<span class="number">1</span>])/<span class="number">2.0</span> + cntrPt[<span class="number">1</span>]</span><br><span class="line">  createPlot.axl.text(xMid, yMid, txtString)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：画决策树的核心函数</span></span><br><span class="line"><span class="comment">#param：</span></span><br><span class="line"><span class="comment">#	myTree    ==&gt; 字典树</span></span><br><span class="line"><span class="comment">#	parentPt  ==&gt; 父节点坐标</span></span><br><span class="line"><span class="comment">#	nodeTxt   ==&gt; 节点内容</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotTree</span><span class="params">(myTree, parentPt, nodeTxt)</span>:</span></span><br><span class="line">  numLeafs = getNumLeafs(myTree) <span class="comment">#叶子节点个数</span></span><br><span class="line">  depth = getTreeDepth(myTree) <span class="comment">#树的高度</span></span><br><span class="line">  firstStr = myTree.keys()[<span class="number">0</span>]</span><br><span class="line">  cntrPt = (plotTree.xOff + (<span class="number">1.0</span> + float(numLeafs))/<span class="number">2.0</span>/plotTree.totalW, plotTree.yOff) <span class="comment">#这里计算x的坐标的方式没看懂？？</span></span><br><span class="line">  plotMidText(cntrPt, parentPt, nodeTxt) <span class="comment">#填充父子节点连线上的内容</span></span><br><span class="line">  plotNode(firstStr, cntrPt, parentPt, decisionNode) <span class="comment">#画出父子节点与其之间的连线</span></span><br><span class="line">  secondDict = myTree[firstStr]</span><br><span class="line">  <span class="comment">#如果决策树不止一个节点</span></span><br><span class="line">  <span class="keyword">if</span> type(secondDict).__name__ == <span class="string">'dict'</span>:</span><br><span class="line">	  plotTree.yOff = plotTree.yOff - <span class="number">1.0</span>/plotTree.totalD</span><br><span class="line">	  <span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():</span><br><span class="line">	  	<span class="keyword">if</span> type(secondDict[key]).__name__ == <span class="string">'dict'</span>:</span><br><span class="line">	  		plotTree(secondDict[key], cntrPt, str(key))</span><br><span class="line">	  	<span class="keyword">else</span>:</span><br><span class="line">	  		plotTree.xOff += <span class="number">1.0</span>/plotTree.totalW</span><br><span class="line">	  		plotNode(secondDict[key], (plotTree.xOff, plotTree.yOff), cntrPt, leafNode)</span><br><span class="line">	  		plotMidText((plotTree.xOff, plotTree.yOff), cntrPt, str(key))</span><br><span class="line">	  plotTree.yOff = plotTree.yOff + <span class="number">1.0</span>/plotTree.totalD</span><br><span class="line"></span><br><span class="line"><span class="comment">#Function：创建图</span></span><br><span class="line"><span class="comment">#param：</span></span><br><span class="line"><span class="comment">#	inTree  ==&gt; 字典树</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createPlot</span><span class="params">(inTree)</span>:</span></span><br><span class="line">  fig = plt.figure(<span class="number">1</span>, facecolor=<span class="string">'white'</span>)</span><br><span class="line">  fig.clf()</span><br><span class="line">  axprops = dict(xticks=[], yticks=[]) <span class="comment">#此参数用于去掉x轴，y轴</span></span><br><span class="line">  createPlot.axl = plt.subplot(<span class="number">111</span>, frameon=<span class="keyword">False</span>, **axprops)</span><br><span class="line">  plotTree.totalW = float(getNumLeafs(inTree)) <span class="comment">#总宽</span></span><br><span class="line">  plotTree.totalD = float(getTreeDepth(inTree)) <span class="comment">#总高</span></span><br><span class="line">  plotTree.xOff = -<span class="number">0.5</span>/plotTree.totalW <span class="comment">#这个初始偏移量没看懂为什么这样设置？？</span></span><br><span class="line">  plotTree.yOff = <span class="number">1.0</span> </span><br><span class="line">  plotTree(inTree, (<span class="number">0.5</span>, <span class="number">1.0</span>), <span class="string">' '</span>)</span><br><span class="line">  plt.show()</span><br></pre></td></tr></table></figure>
<p> [参考资料]</p>
<ol>
<li><a href="">机器学习实战</a></li>
<li><a href="http://pan.baidu.com/s/1eQEOOCU" target="_blank" rel="external">本文用到的代码与数据样本</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[最近在看一本叫做机器学习实战的书，感觉写的不错，因为它里面不仅仅讲一些算法的原理，而且最关键的是用python代码实现了其中的应用场景，这里就是一些读书笔记。这次记录的是决策树算法中的ID3算法。]]>
    
    </summary>
    
      <category term="机器学习" scheme="https://ningban.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Machine Learning" scheme="https://ningban.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[k-近邻算法]]></title>
    <link href="https://ningban.github.io/2015/03/19/knn-algorithm/"/>
    <id>https://ningban.github.io/2015/03/19/knn-algorithm/</id>
    <published>2015-03-19T06:20:16.000Z</published>
    <updated>2015-03-21T15:44:48.000Z</updated>
    <content type="html"><![CDATA[<p>　　最近在看一本叫做机器学习实战的书，感觉写的不错，因为它里面不仅仅将一些算法的原理，而且最关键的是用python代码实现了其中的应用场景，这里就是一些读书笔记。这次记录的是k邻近算法kNN，简单地说，k-近邻算法采用测量不同特征值之间的距离的方法进行分类。<br> 　　<code>它的工作原理</code>是：存在一个样本数据集合，也称作训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每一数据与所属分类的对应关系。输入没有标签的数据后，将新数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本集中特征最相似数据（最近邻）的分类标签。一般来说，我们只选择样本数据集中前k个最相似的数据，这就是k-近邻算法中k的出处，通常k是不大于20的整数。最后，选择k个最相似数据中出现次数最多的分类，作为新数据的分类。<br> 　　<code>k-近邻算法的一般流程</code>：<br> 　　1. 收集数据：可以使用任何方法；<br> 　　2. 准备数据：距离计算所需要的数值，最好是结构化的数据格式；<br> 　　3. 分析数据：可以使用任何方法；<br> 　　4. 训练算法：此步骤不是用于k-近邻算法；<br> 　　5. 测试算法：计算错误率；<br> 　　6. 使用算法：首先需要输入样本数据和结构化的输出结果，然后运行k-临近算法判定输入数据分别属于哪个分类，最后应用对计算出的分类执行后续的处理。<br> 　　<code>程序代码如下</code>：<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="comment">#FileName:KNN.py</span></span><br><span class="line"><span class="string">'''</span><br><span class="line">k近邻算法（kNN: k Nearest Neighbors）</span><br><span class="line">Input:      inX: vector to compare to existing dataset (1xN)</span><br><span class="line">            dataSet: size m data set of known vectors (NxM)</span><br><span class="line">            labels: data set labels (1xM vector)</span><br><span class="line">            k: number of neighbors to use for comparison (should be an odd number)</span><br><span class="line">            </span><br><span class="line">Output:     the most popular class label</span><br><span class="line"></span><br><span class="line">'''</span></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> listdir</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建数据集</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createDataSet</span><span class="params">()</span>:</span></span><br><span class="line">    group = array([[<span class="number">1.0</span>,<span class="number">1.1</span>],[<span class="number">1.0</span>,<span class="number">1.0</span>],[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0.1</span>]])</span><br><span class="line">    labels = [<span class="string">'A'</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'B'</span>]</span><br><span class="line">    <span class="keyword">return</span> group,labels</span><br><span class="line"></span><br><span class="line"><span class="comment">#kNN算法具体实现</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classify0</span><span class="params">(inX, dataSet, labels, k)</span>:</span></span><br><span class="line">    dataSetSize = dataSet.shape[<span class="number">0</span>]</span><br><span class="line">    diffMat = tile(inX, (dataSetSize,<span class="number">1</span>)) - dataSet</span><br><span class="line">    sqDiffMat = diffMat**<span class="number">2</span></span><br><span class="line">    sqDistance = sqDiffMat.sum(axis=<span class="number">1</span>)</span><br><span class="line">    distances = sqDistance**<span class="number">0.5</span></span><br><span class="line">    sortedDistIndicies = distances.argsort()</span><br><span class="line">    classCount=&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">	voteIlabel = labels[sortedDistIndicies[i]]</span><br><span class="line">	classCount[voteIlabel] = classCount.get(voteIlabel,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">	sortedClassCount = sorted(classCount.iteritems(),</span><br><span class="line">	 key= operator.itemgetter(<span class="number">1</span>), reverse=<span class="keyword">True</span>)</span><br><span class="line">    <span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#将文本文档转换为矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">file2matrix</span><span class="params">(filename)</span>:</span></span><br><span class="line">    fr = open(filename)</span><br><span class="line">    arrayOLines = fr.readlines()</span><br><span class="line">    numberofLines = len(arrayOLines)</span><br><span class="line">    returnMat = zeros((numberofLines, <span class="number">3</span>))</span><br><span class="line">    classLabelVector = []</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> arrayOLines:</span><br><span class="line">	line = line.strip()</span><br><span class="line">	listFromLine = line.split(<span class="string">'\t'</span>)</span><br><span class="line">	returnMat[index,:]=listFromLine[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">	classLabelVector.append(int(listFromLine[-<span class="number">1</span>]))</span><br><span class="line">	index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> returnMat,classLabelVector</span><br><span class="line"></span><br><span class="line"><span class="comment">#为了解决每个因素影响结果的权重问题，对数据集进行归一化处理</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">autoNorm</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">  minVals = dataSet.min(<span class="number">0</span>)</span><br><span class="line">  maxVals = dataSet.max(<span class="number">0</span>)</span><br><span class="line">  ranges = maxVals - minVals</span><br><span class="line">  normDataSet = zeros(shape(dataSet))</span><br><span class="line">  m = dataSet.shape[<span class="number">0</span>]</span><br><span class="line">  normDataSet = dataSet -tile(minVals, (m,<span class="number">1</span>))</span><br><span class="line">  normDataSet = normDataSet/tile(ranges, (m,<span class="number">1</span>))</span><br><span class="line">  <span class="keyword">return</span> normDataSet, ranges, minVals</span><br><span class="line"></span><br><span class="line"><span class="comment">#================将KNN用于约会网站=============================================================</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">#例1：从数据集合中选择10%作为测试数据集，使用KNN进行预测，并计算算法的错误率</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">datingClassTest</span><span class="params">()</span>:</span></span><br><span class="line">  hoRatio = <span class="number">0.10</span> </span><br><span class="line">  datingDataMat, datingLabels = file2matrix(<span class="string">'datingTestSet.txt'</span>)</span><br><span class="line">  normMat, ranges, minVals = autoNorm(datingDataMat)</span><br><span class="line">  m = normMat.shape[<span class="number">0</span>]</span><br><span class="line">  numTestVecs = int(m*hoRatio)</span><br><span class="line">  errorCount = <span class="number">0.0</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(numTestVecs):</span><br><span class="line">  	classifierResult = classify0(normMat[i,:], normMat[numTestVecs:m],\</span><br><span class="line">  		datingLabels[numTestVecs:m],<span class="number">3</span>)</span><br><span class="line">  	<span class="keyword">print</span> <span class="string">'the classifier came back with: %d, the real answer is :%d'</span>\</span><br><span class="line">  		%(classifierResult, datingLabels[i])</span><br><span class="line">  	<span class="keyword">if</span>(classifierResult != datingLabels[i]):</span><br><span class="line">  		errorCount += <span class="number">1.0</span></span><br><span class="line">  <span class="keyword">print</span> <span class="string">'the total error rate is : %f'</span> %(errorCount/float(numTestVecs))</span><br><span class="line"></span><br><span class="line"><span class="comment">#例2：给定一个人的所需信息，使用KNN进行预测</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classifyPerson</span><span class="params">()</span>:</span></span><br><span class="line">  resultList = [<span class="string">'not at all'</span>, <span class="string">'in samll doses'</span>, <span class="string">'in large doses'</span>]</span><br><span class="line">  percentTats = float(raw_input(\</span><br><span class="line">  	<span class="string">'percetage of time spent playing video games?'</span>))</span><br><span class="line">  ffMiles = float(raw_input(\</span><br><span class="line">  	<span class="string">'frequent fier miles earned per year?'</span>))</span><br><span class="line">  iceCream = float(raw_input(\</span><br><span class="line">  	<span class="string">'liters of ice cream consumed per year?'</span>))</span><br><span class="line">  datingDataMat, datingLabels = file2matrix(<span class="string">'datingTestSet.txt'</span>)</span><br><span class="line">  normMat, ranges, minVals = autoNorm(datingDataMat)</span><br><span class="line">  inArr = array([ffMiles, percentTats, iceCream])</span><br><span class="line">  classifierResult = classify0((inArr-minVals)/ranges, normMat, datingLabels,<span class="number">3</span>)</span><br><span class="line">  <span class="keyword">print</span> <span class="string">'You will probably like this person:'</span>,\</span><br><span class="line">  	resultList[classifierResult-<span class="number">1</span>]   <span class="comment">#index start from 0, data start from 1, so minus 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#==============将KNN用于图像识别======================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将32*32的二进制文本格式的图像转换为1*1024的向量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img2vector</span><span class="params">(filename)</span>:</span></span><br><span class="line">  returnVect = zeros((<span class="number">1</span>, <span class="number">1024</span>))</span><br><span class="line">  fr = open(filename)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">	lineStr = fr.readline()</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">		returnVect[<span class="number">0</span>, <span class="number">32</span>*i+j] = int(lineStr[j]) </span><br><span class="line">  <span class="keyword">return</span> returnVect</span><br><span class="line"></span><br><span class="line"><span class="comment">#手写识别例子</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handwritingClassTest</span><span class="params">()</span>:</span></span><br><span class="line">  hwLabels = []</span><br><span class="line">  trainingFileList = listdir(<span class="string">'trainingDigits'</span>)</span><br><span class="line">  m = len(trainingFileList)</span><br><span class="line">  trainingMat = zeros((m, <span class="number">1024</span>))</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">  	fileNameStr = trainingFileList[i]</span><br><span class="line">  	fileStr = fileNameStr.split(<span class="string">'.'</span>)[<span class="number">0</span>]</span><br><span class="line">  	classNumStr = int(fileStr.split(<span class="string">'_'</span>)[<span class="number">0</span>])</span><br><span class="line">  	hwLabels.append(classNumStr)</span><br><span class="line">  	trainingMat[i, :] = img2vector(<span class="string">'trainingDigits/%s'</span> %fileNameStr)</span><br><span class="line">  testFileList = listdir(<span class="string">'testDigits'</span>)</span><br><span class="line">  errorCount = <span class="number">0.0</span></span><br><span class="line">  mTest = len(testFileList)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(mTest):</span><br><span class="line">  	fileNameStr = testFileList[i]</span><br><span class="line">  	fileStr = fileNameStr.split(<span class="string">'.'</span>)[<span class="number">0</span>]</span><br><span class="line">  	classNumStr = int(fileStr.split(<span class="string">'_'</span>)[<span class="number">0</span>])</span><br><span class="line">  	vectorUnderTest = img2vector(<span class="string">'testDigits/%s'</span> %fileNameStr)</span><br><span class="line">  	classifierResult = classify0(vectorUnderTest, \</span><br><span class="line">  		trainingMat, hwLabels, <span class="number">3</span>)</span><br><span class="line">  	<span class="keyword">print</span> <span class="string">'the classifier came back with: %d, the real answer is : %d'</span>\</span><br><span class="line">  		%(classifierResult, classNumStr)</span><br><span class="line">  	<span class="keyword">if</span>(classifierResult != classNumStr):</span><br><span class="line">  		errorCount += <span class="number">1.0</span></span><br><span class="line">  <span class="keyword">print</span> <span class="string">'\nthe total number of errors is : %d'</span> %errorCount</span><br><span class="line">  <span class="keyword">print</span> <span class="string">'\nthe total error rate is: %f'</span> %(errorCount/float(mTest))</span><br></pre></td></tr></table></figure></p>
<p> [参考资料]</p>
<ol>
<li><a href="">机器学习实战</a></li>
<li><a href="http://pan.baidu.com/s/1eQEOOCU" target="_blank" rel="external">本文用到的代码与数据样本</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[最近在看一本叫做机器学习实战的书，感觉写的不错，因为它里面不仅仅讲一些算法的原理，而且最关键的是用python代码实现了其中的应用场景，这里就是一些读书笔记。这次记录的是k邻近算法k-NN（k-Nearest Neighbor），简单地说，k-近邻算法采用测量不同特征值之间的距离的方法进行分类。]]>
    
    </summary>
    
      <category term="机器学习" scheme="https://ningban.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Machine Learning" scheme="https://ningban.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[升级hexo3遇到的坑]]></title>
    <link href="https://ningban.github.io/2015/03/19/hexo3-is-awesome/"/>
    <id>https://ningban.github.io/2015/03/19/hexo3-is-awesome/</id>
    <published>2015-03-19T04:33:36.000Z</published>
    <updated>2015-03-21T15:13:43.000Z</updated>
    <content type="html"><![CDATA[<p>　　我本来的hexo版本是2.8，现在使用按照<a href="http://hexo.io/docs/" target="_blank" rel="external">官方教程</a>安装的都会默认安装hexo3。最近一直在使用unbuntu系统，但是我的hexo时安装在了windows系统之下，如果想要写一篇博客还需要来回切换系统，太麻烦了（我的是双系统），悲剧就是这样发生的。too young, too simple的我首先采取了windows和ubuntu共享hexo文件夹的办法，我直接执行hexo generate命令，结果肯定是报错了，傻傻我的搜索了半天，不知所以然，就采取了hexo init，悲剧的事情发生了，hexo文件夹下的_config.yml文件被覆盖掉了，我的网站配置就直接会到了原始版，此时的我只能重新配置（PS：此时我用的主体是pacman），当所有的工作都配置好之后，我发现rss和sitemap不好使，最关键的是python代码的样式都没了，经过长时间的搜索，知道了hexo3是个坑的结论，看样螃蟹确实不是那么好吃的。于是乎，我又想办法把hexo降级，最终来到了<a href="https://coderq.com/t/hexojiang-ji-3-dot-0-to-2-dot-8/1851" target="_blank" rel="external">这里</a>。我尝试了n次之后，发现按照作者的方法对我来说不可行，总是报出关于node中js的错误，此时我以为是node的版本问题，之后我又走向了卸载/重装nodejs的不归路。经过一番折腾，发现即使重新安装nodejs，hexo还是会出现和重装之前一样的错误，好吧，我又走了弯路。最后，终于发现pacman不支持hexo3，至此我已经从下午两点搞到了晚上十一点（PS：出去吃饭/喝水/回宿舍等其他繁杂时间），后来发现jacman支持了hexo3，我果断地选择了jacman主题，这个主题是来源于pacman，开发jacman主题的author貌似进入了他梦寐以求的阿里，这里也恭喜他。好了，回归正题，选择新的主题之后，我选择在ubuntu下新建立一个文件夹用于存放hexo文件，之后的一切还是比较顺利的，可惜今早又折腾了一早，因为我又遇到坑了。<br>　　<code>The first坑：</code>执行hexo deploy命令，报出如下错误：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Error:</span> Deployer not <span class="string">found :</span> github</span><br></pre></td></tr></table></figure></p>
<p>解决方法是执行如下命令：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="operator"><span class="keyword">install</span> hexo-deployer-git <span class="comment">--save</span></span></span><br></pre></td></tr></table></figure></p>
<p>同时修改_config.yml：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git      <span class="comment">//github&gt;&gt;git</span></span><br></pre></td></tr></table></figure></p>
<p>　　<code>The second坑：</code>部署到github之后，<a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="external">rss</a>和<a href="https://github.com/hexojs/hexo-generator-sitemap" target="_blank" rel="external">sitemap</a>插件没有起到作用，解决方法是执行如下命令：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="operator"><span class="keyword">install</span> hexo-generator-feed <span class="comment">--save</span></span><br><span class="line">$ npm <span class="keyword">install</span> hexo-generator-sitemap <span class="comment">--save</span></span></span><br></pre></td></tr></table></figure></p>
<p>　　<code>The third坑：</code>（PS：这个不能算坑，只能算是我的问题）多说无法使用，解决方法就是修改jacman主题的_config.yml，把其中的duoshuo_shortname写上你的shortname就可以了，当然首先你要去多说去注册一个账号才行。<br> 　　<code>The fourth坑：</code>关于jacman支持LaTex数学公式，jacman里面很简单，只需要在文章开头的front-matter中，加上一行mathjax: true。那么问题来了，什么叫做front-matter呢？请原谅我的对hexo的无知，搜索了之后才知道是文章的md文件中三个短线上面的配置，如title，date等配置，如下所示：<br> <figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">title: <span class="string">"升级hexo3遇到的坑"</span></span><br><span class="line">date: <span class="number">2015</span>-<span class="number">03</span>-<span class="number">19</span> <span class="number">12</span>:<span class="number">33</span>:<span class="number">36</span></span><br><span class="line">categories: Hexo</span><br><span class="line">tags:  [Hexo]</span><br><span class="line">mathjax: true</span><br><span class="line">---</span><br><span class="line">从这里开始是正文<span class="keyword">...</span></span><br></pre></td></tr></table></figure></p>
<p>　　这样配置好之后，我以为就可以随心所欲的写LaTex数学公式了，可惜我又入坑了。当我写两个数学公式的时候，我以为直接分别在不同的行写就可以了，可是经过我一番折腾才发现在<code>写第二个数学公式之前一定要留上一个空行</code>才可以，否则数学公式显示失效，其他类似情况也是一样。正确的姿势如下所示：<br>$$l(x_i) = -log_2(p(x_i))$$ </p>
<p>$$H = -\sum_{i=1}^n p(x_i)log_2p(x_i)$$<br>　　对了，忘记说了最后一点，以后一定要先把hexo整个文件夹备份一份，或者至少要备份source文件夹和主题文件夹，以及根目录下的_config.yml文件这三个，否则产生的后果，你懂的。</p>
<p>[参考资料]</p>
<ol>
<li><a href="https://coderq.com/t/hexojiang-ji-3-dot-0-to-2-dot-8/1851" target="_blank" rel="external">Hexo降级3.0 to 2.8</a></li>
<li><a href="https://github.com/wuchong/jacman" target="_blank" rel="external">jacman</a></li>
<li><a href="http://www.cnblogs.com/liulangmao/p/4323064.html" target="_blank" rel="external">使用hexo搭建github.io博客(一)</a></li>
<li><a href="http://hexo.io/docs/" target="_blank" rel="external">Hexo Docs</a></li>
<li><a href="https://github.com/hexojs/hexo/wiki/plugins" target="_blank" rel="external">Hexo Plugins</a></li>
<li><a href="http://wuchong.me" target="_blank" rel="external">Jac’s Blog</a></li>
<li><a href="http://dwayneten.com/2015/02/26/New-Blog/" target="_blank" rel="external">Hello Blog</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[最近一直在使用unbuntu系统，但是我的hexo时安装在了windows系统之下，如果想要写一篇博客还需要来回切换系统，太麻烦了（我的是双系统），悲剧就是这样发生的。]]>
    
    </summary>
    
      <category term="Hexo" scheme="https://ningban.github.io/tags/Hexo/"/>
    
      <category term="Hexo" scheme="https://ningban.github.io/categories/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Chrome插件推荐]]></title>
    <link href="https://ningban.github.io/2015/03/08/Chrome%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    <id>https://ningban.github.io/2015/03/08/Chrome插件推荐/</id>
    <published>2015-03-08T11:41:24.000Z</published>
    <updated>2015-03-08T12:48:32.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7vihec.com1.z0.glb.clouddn.com/chrome.jpg" alt="chrome"><br>　　寒假结束了，好久没有写东西了，最近在v2ex上看到12年发表一个关于<a href="https://www.v2ex.com/t/37709" target="_blank" rel="external">好用的Chrome插件</a>的讨论，看了之后收获挺多的，在这里也把我常用的Chrome插件推荐一下，也当作记录之用。</p>
<ul>
<li>SwitchyOmega<blockquote>
<p>这个插件的名字以前叫做Switch Sharp，作者又重新写了一个并且改成了这个名字，原来的由于扩展性问题，不更新了。至于他的功能的话，你懂的，不懂的话，问Google吧。</p>
</blockquote>
</li>
<li>LastPass<blockquote>
<p>自从有了它，密码什么的再也不用担心了，不仅可以记录所有的密码，而且可以自动生成密码，所以以往一个密码通天下的时代结束了。</p>
</blockquote>
</li>
<li>Pocket<blockquote>
<p>这个插件又叫做稍后阅读，就是在浏览网页看到的内容如果没时间看，可以先放在这里，以后可以再在这里看。</p>
</blockquote>
</li>
<li>印象笔记·剪藏<blockquote>
<p>这个和上面的功能基本是一样的，对于代码的保存也更友好一些。</p>
</blockquote>
</li>
<li>Tampermonkey<blockquote>
<p>这个插件可是用一个字”厉害”来形容了，自从有了它，所有网站的自动签到神马的，百度云盘上资源的搜索神马的等等都搞定了。<a href="https://greasyfork.org/zh-CN" target="_blank" rel="external">点这里</a>去找到自己想用的用户脚本吧。</p>
</blockquote>
</li>
<li>Google翻译<blockquote>
<p>这个不用说了吧，就是看英文的时候的划词翻译功能，也支持右键搜索，但是好像需要越过功夫网才可以。</p>
</blockquote>
</li>
<li>Adblock<blockquote>
<p>这个插件用于屏蔽网页上的广告的，当然有些视频网站的广告也是可以的哦。也有些朋友推荐使用μblock，它们的功能大体是差不多的。</p>
</blockquote>
</li>
<li>Better History<blockquote>
<p>这个插件用于有条理的查看Chrome的浏览历史。</p>
</blockquote>
</li>
<li>有道云笔记·剪藏<blockquote>
<p>这个插件和印象笔记的差不多，但是存储空间很大的说。</p>
</blockquote>
</li>
<li>一键管理<blockquote>
<p>这个插件用于管理Chrome上的所有插件，如果所有的插件都运行可能会卡，所以有了它，想开启哪个开启哪个。</p>
</blockquote>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[这里推荐我常用并且非常不错的chrome插件。]]>
    
    </summary>
    
      <category term="分享与发现" scheme="https://ningban.github.io/tags/%E5%88%86%E4%BA%AB%E4%B8%8E%E5%8F%91%E7%8E%B0/"/>
    
      <category term="分享与发现" scheme="https://ningban.github.io/categories/%E5%88%86%E4%BA%AB%E4%B8%8E%E5%8F%91%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python入门笔记]]></title>
    <link href="https://ningban.github.io/2015/01/21/Python%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
    <id>https://ningban.github.io/2015/01/21/Python入门笔记/</id>
    <published>2015-01-21T15:05:44.000Z</published>
    <updated>2015-03-19T06:31:44.000Z</updated>
    <content type="html"><![CDATA[<h1 id="注释">注释</h1><p> 　　Python至少应当有第一行那样的特殊形式的注释。它被称作 组织行 ——源文件的头两个字符是#!，后面跟着一个程序。这行告诉你的Linux/Unix系统当你执行你的程序的时候，它应该运行哪个解释器。注意，你总是可以通过直接在命令行指定解释器，从而在任何平台上运行你的程序，就如同命令python helloworld.py一样。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ chmod a+x helloworld.py</span><br><span class="line">$ ./helloworld.py</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure></p>
<p>　　为了更加有趣一些，你可以把你的文件名改成helloworld，然后运行./helloworld。这样，这个程序仍然可以工作,因为系统知道它必须用源文件第一行指定的那个解释器来运行程序。可以把你的程序保存在PATH环境变量中的目录之一，每当你运行任何程序，系统会查找列在PATH环境变量中的各个目录，然后运行那个程序。</p>
<h1 id="参数">参数</h1><p>　　只有在形参末尾的那些参数可以有默认参数值，即你不能在声明函数形参的时候，先声明有默认值的形参而后声明没有默认值的形参。这是因为赋给形参的值是根据位置而赋值的，例如：def func(a, b=5)是有效的，但是def func(a=5, b)是无效的。</p>
<h1 id="文档字符串DocStrings">文档字符串DocStrings</h1><p>　　文档字符串的惯例是一个多行字符串，它的首行以大写字母开始，句号结尾。第二行是空行，从第三行开始是详细的描述。强烈建议你在你的函数中使用文档字符串时遵循这个惯例。自动化工具也可以以同样的方式从你的程序中提取文档。因此,我强烈建议你对你所写的任何正式函数编写文档字符串。随你的Python发行版附带的pydoc命令，与help()类似地使用DocStrings。</p>
<h1 id="sys模块">sys模块</h1><p>　　sys模块包含了与Python解释器和它的环境有关的函数。<br>　　当Python执行import sys语句的时候，它在sys.path变量所列目录中寻找sys.py模块。如果找到了这个文件，这个模块的主块中的语句将被运行，然后这个模块将能够被你使用。注意，初始化过程仅在我们第一次输入模块的时候进行。<br>　　这里，当我们执行python using_sys.py we are arguments的时候,我们使用python命令运行using_sys.py模块，后面跟着的内容被作为参数传递给程序。Python为我们把它存储在sys.argv变量中。<br>　　<strong>PS：</strong>一般说来，应该避免使用from..import而使用import语句，因为这样可以使你的程序更加易读，也可以避免名称的冲突。</p>
<h1 id="__name__模块">__name__模块</h1><p>　　例如<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: using_name.py</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'This program is being run by itself'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'I am being imported from another module'</span></span><br></pre></td></tr></table></figure></p>
<p>　　这里表示，如果执行python using_name.py时，则__name__=’__main__‘；如果执行import using_name，则__name__=’using_name’。</p>
<h1 id="dir()函数">dir()函数</h1><p>　　你可以使用内建的dir函数来列出模块定义的标识符，识符有函数、类和变量。当你为dir()提供一个模块名的时候,它返回模块定义的名称列表；如果不提供参数，它返回当前模块中定义的名称列表。</p>
<h1 id="数据结构">数据结构</h1><p>　　在Python中有三种内建的数据结构——列表list、元组tuple和字典dict。</p>
<h2 id="列表">列表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: using_list.py</span></span><br><span class="line"><span class="comment"># This is my shopping list</span></span><br><span class="line">shoplist = [<span class="string">'apple'</span>, <span class="string">'mango'</span>, <span class="string">'carrot'</span>, <span class="string">'banana'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'I have'</span>, len(shoplist),<span class="string">'items to purchase.'</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'These items are:'</span>, <span class="comment"># Notice the comma at end of the line</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> shoplist:</span><br><span class="line">    <span class="keyword">print</span> item,</span><br><span class="line"><span class="keyword">print</span> <span class="string">'\nI also have to buy rice.'</span></span><br><span class="line">shoplist.append(<span class="string">'rice'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'My shopping list is now'</span>, shoplist</span><br><span class="line"><span class="keyword">print</span> <span class="string">'I will sort my list now'</span></span><br><span class="line">shoplist.sort()</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Sorted shopping list is'</span>, shoplist</span><br><span class="line"><span class="keyword">print</span> <span class="string">'The first item I will buy is'</span>, shoplist[<span class="number">0</span>]</span><br><span class="line">olditem = shoplist[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">del</span> shoplist[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'I bought the'</span>, olditem</span><br><span class="line"><span class="keyword">print</span> <span class="string">'My shopping list is now'</span>, shoplist</span><br></pre></td></tr></table></figure>
<h2 id="元组">元组</h2><p>　　元组和列表十分类似，只不过元组和字符串一样是不可变的，即你不能修改元组。元组通过圆括号中用逗号分割的项目定义。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: using_tuple.py</span></span><br><span class="line">zoo = (<span class="string">'wolf'</span>, <span class="string">'elephant'</span>, <span class="string">'penguin'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Number of animals in the zoo is'</span>, len(zoo)</span><br><span class="line">new_zoo = (<span class="string">'monkey'</span>, <span class="string">'dolphin'</span>, zoo)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Number of animals in the new zoo is'</span>, len(new_zoo)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'All animals in new zoo are'</span>, new_zoo</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Animals brought from old zoo are'</span>, new_zoo[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Last animal brought from old zoo is'</span>, new_zoo[<span class="number">2</span>][<span class="number">2</span>]</span><br></pre></td></tr></table></figure></p>
<p>　　一个空的元组由一对空的圆括号组成，如myempty = ()。然而，含有单个元素的元组就不那么简单了，你必须在第一个(唯一一个)项目后跟一个逗号,这样Python才能区分元组和表达式中一个带圆括号的对象。即如果你想要的是一个包含项目2的元组的时候，你应该指明singleton = (2 , )。<br>　　元组最通常的用法是用在打印语句中，下面是一个例子:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: print_tuple.py</span></span><br><span class="line">age = <span class="number">22</span></span><br><span class="line">name = <span class="string">'Swaroop'</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'%s is %d years old'</span> % (name, age)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Why is %s playing with that python?'</span> % name</span><br></pre></td></tr></table></figure></p>
<p>　　在第二个print语句中,我们使用了一个定制，后面跟着%符号后的单个项目——没有圆括号，这只在字符串中只有一个定制的时候有效。</p>
<h2 id="字典">字典</h2><p>　　你只能使用不可变的对象(比如字符串)来作为字典的键，但是你可以把不可变或可变的对象作为字典的值。键值对在字典中以这样的方式标记:d = {key1 : value1, key2 : value2 }。注意，它们的键/值对用冒号分割，而各个对用逗号分割，所有这些都包括在花括号中。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: using_dict.py</span></span><br><span class="line"><span class="comment"># 'ab' is short for 'a'ddress'b'ook</span></span><br><span class="line">ab = &#123;</span><br><span class="line">    <span class="string">'Swaroop'</span> : <span class="string">'swaroopch@byteofpython.info'</span>,</span><br><span class="line">    <span class="string">'Larry'</span> : <span class="string">'larry@wall.org'</span>,</span><br><span class="line">    <span class="string">'Matsumoto'</span> : <span class="string">'matz@ruby-lang.org'</span>,</span><br><span class="line">    <span class="string">'Spammer'</span> : <span class="string">'spammer@hotmail.com'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Swaroop's address is %s"</span> % ab[<span class="string">'Swaroop'</span>]</span><br><span class="line"><span class="comment"># Adding a key/value pair</span></span><br><span class="line">ab[<span class="string">'Guido'</span>] = <span class="string">'guido@python.org'</span></span><br><span class="line"><span class="comment"># Deleting a key/value pair</span></span><br><span class="line"><span class="keyword">del</span> ab[<span class="string">'Spammer'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'\nThere are %d contacts in the address-book\n'</span> % len(ab)</span><br><span class="line"><span class="keyword">for</span> name, address <span class="keyword">in</span> ab.items():</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Contact %s at %s'</span> % (name, address)</span><br><span class="line"><span class="keyword">if</span> <span class="string">'Guido'</span> <span class="keyword">in</span> ab: <span class="comment"># OR ab.has_key('Guido')</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"\nGuido's address is %s"</span> % ab[<span class="string">'Guido'</span>]</span><br></pre></td></tr></table></figure></p>
<h1 id="序列">序列</h1><p>　　列表、元组和字符串都是序列，但是序列是什么，它们为什么如此特别呢？序列的两个主要特点是索引操作符和切片操作符。索引操作符让我们可以从序列中抓取一个特定项目。切片操作符让我们能够获取序列的一个切片，即一部分序列。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: seq.py</span></span><br><span class="line">shoplist = [<span class="string">'apple'</span>, <span class="string">'mango'</span>, <span class="string">'carrot'</span>, <span class="string">'banana'</span>]</span><br><span class="line"><span class="comment"># Indexing or 'Subscription' operation</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Item 0 is'</span>, shoplist[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Item 1 is'</span>, shoplist[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Item 2 is'</span>, shoplist[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Item 3 is'</span>, shoplist[<span class="number">3</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Item -1 is'</span>, shoplist[-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Item -2 is'</span>, shoplist[-<span class="number">2</span>]</span><br><span class="line"><span class="comment"># Slicing on a list</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Item 1 to 3 is'</span>, shoplist[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Item 2 to end is'</span>, shoplist[<span class="number">2</span>:]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Item 1 to -1 is'</span>, shoplist[<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Item start to end is'</span>, shoplist[:]</span><br><span class="line"><span class="comment"># Slicing on a string</span></span><br><span class="line">name = <span class="string">'swaroop'</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'characters 1 to 3 is'</span>, name[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'characters 2 to end is'</span>, name[<span class="number">2</span>:]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'characters 1 to -1 is'</span>, name[<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'characters start to end is'</span>, name[:]</span><br></pre></td></tr></table></figure></p>
<p>　　注意，返回的序列从开始位置开始，刚好在结束位置之前结束。即开始位置是包含在序列切片中的，而结束位置被排斥在切片外。</p>
<h1 id="引用">引用</h1><p>　　当你创建一个对象并给它赋一个变量的时候，这个变量仅仅引用那个对象，而不是表示这个对象本身！也就是说，变量名指向你计算机中存储那个对象的内存，这被称作名称到对象的绑定。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: reference.py</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Simple Assignment'</span></span><br><span class="line">shoplist = [<span class="string">'apple'</span>, <span class="string">'mango'</span>, <span class="string">'carrot'</span>, <span class="string">'banana'</span>]</span><br><span class="line">mylist = shoplist <span class="comment"># mylist is just another name pointing to the same object!</span></span><br><span class="line"><span class="keyword">del</span> shoplist[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'shoplist is'</span>, shoplist</span><br><span class="line"><span class="keyword">print</span> <span class="string">'mylist is'</span>, mylist</span><br><span class="line"><span class="comment"># notice that both shoplist and mylist both print the same list without</span></span><br><span class="line"><span class="comment"># the 'apple' confirming that they point to the same object</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Copy by making a full slice'</span></span><br><span class="line">mylist = shoplist[:] <span class="comment"># make a copy by doing a full slice</span></span><br><span class="line"><span class="keyword">del</span> mylist[<span class="number">0</span>] <span class="comment"># remove first item</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'shoplist is'</span>, shoplist</span><br><span class="line"><span class="keyword">print</span> <span class="string">'mylist is'</span>, mylist</span><br><span class="line"><span class="comment"># notice that now the two lists are different</span></span><br></pre></td></tr></table></figure></p>
<p>　　记住列表的赋值语句不创建拷贝，你得使用切片操作符来建立序列的拷贝。</p>
<h1 id="字符串">字符串</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: str_methods.py</span></span><br><span class="line">name = <span class="string">'Swaroop'</span> <span class="comment"># This is a string object</span></span><br><span class="line"><span class="keyword">if</span> name.startswith(<span class="string">'Swa'</span>):</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Yes, the string starts with "Swa"'</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">'a'</span> <span class="keyword">in</span> name:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Yes, it contains the string "a"'</span></span><br><span class="line"><span class="keyword">if</span> name.find(<span class="string">'war'</span>) != -<span class="number">1</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Yes, it contains the string "war"'</span></span><br><span class="line">delimiter = <span class="string">'_*_'</span></span><br><span class="line">mylist = [<span class="string">'Brazil'</span>, <span class="string">'Russia'</span>, <span class="string">'India'</span>, <span class="string">'China'</span>]</span><br><span class="line"><span class="keyword">print</span> delimiter.join(mylist)</span><br></pre></td></tr></table></figure>
<h1 id="例子：文件备份">例子：文件备份</h1><p>　　我认为优化之一是采用更好的文件名机制——使用时间作为文件名，而把当前的日期作为目录名，存放在主备份目录中。这样做的一个优势是你的备份会以等级结构存储,因此它就更加容易管理了。另外一个优势是文件名的长度也可以变短。还有一个优势是采用各自独立的文件夹可以帮助你方便地检验你是否在每一天创建了备份，因为只有在你创建了备份，才会出现那天的目录。<br>　　我还希望有的一个优化是使用tar命令替代zip命令。这样做的一个优势是在你结合使用tar和gzip命令的时候，备份会更快更小。<br>　　最理想的创建这些归档的方法是分别使用zipfile和tarfile。它们是Python标准库的一部分，可以供你使用。使用这些库就避免了使用os.system这个不推荐使用的函数，它容易引发严重的错误。</p>
<h1 id="面向过程与面向对象">面向过程与面向对象</h1><p>　　到目前为止，在我们的程序中，我们都是根据操作数据的函数或语句块来设计程序的。这被称为面向过程的编程。还有一种把数据和功能结合起来，用称为对象的东西包裹起来组织程序的方法。这种方法称为面向对象的编程理念。</p>
<h1 id="self">self</h1><p>　　假如你有一个类称为MyClass和这个类的一个实例MyObject。当你调用这个对象的方法MyObject.method(arg1, arg2)的时候,这会由Python自动转为MyClass.method(MyObject, arg1,arg2)——这就是self的原理了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: method.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayHi</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Hello, how are you?'</span></span><br><span class="line">p = Person()</span><br><span class="line">p.sayHi()</span><br><span class="line"><span class="comment"># This short example can also be written as Person().sayHi()</span></span><br></pre></td></tr></table></figure></p>
<h1 id="__init__与__del__">__init__与__del__</h1><p>　　__init__方法类似于C++、C#和Java中的 constructor 。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: class_init.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayHi</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Hello, my name is'</span>, self.name</span><br><span class="line">p = Person(<span class="string">'Swaroop'</span>)</span><br><span class="line">p.sayHi()</span><br><span class="line"><span class="comment"># This short example can also be written as Person('Swaroop').sayHi()</span></span><br></pre></td></tr></table></figure></p>
<p>　　就如同__init__方法一样，还有一个特殊的方法__del__，它在对象消逝的时候被调用。对象消逝即对象不再被使用，它所占用的内存将返回给系统作它用。当对象不再被使用时，__del__方法运行，但是很难保证这个方法究竟在 什么时候运行。</p>
<h1 id="类与对象的变量">类与对象的变量</h1><p>　　有两种类型的域——类的变量和对象的变量，它们根据是类还是对象拥有这个变量而区分。<br>　　类的变量由一个类的所有对象(实例)共享使用。只有一个类变量的拷贝，所以当某个对象对类的变量做了改动的时候，这个改动会反映到所有其他的实例上。<br>　　对象的变量由类的每个对象/实例拥有。因此每个对象有自己对这个域的一份拷贝，即它们不是共享的，在同一个类的不同实例中，虽然对象的变量有相同的名称，但是是互不相关的。通过一个例子会使这个易于理解。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: objvar.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="string">'''Represents a person.'''</span></span><br><span class="line">    population = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="string">'''Initializes the person's data.'''</span></span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'(Initializing %s)'</span> % self.name</span><br><span class="line">        <span class="comment"># When this person is created, he/she</span></span><br><span class="line">        <span class="comment"># adds to the population</span></span><br><span class="line">        Person.population += <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''I am dying.'''</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'%s says bye.'</span> % self.name</span><br><span class="line">        Person.population -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> Person.population == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'I am the last one.'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'There are still %d people left.'</span> % Person.population</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayHi</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''Greeting by the person.</span><br><span class="line">            Really, that's all it does.'''</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Hi, my name is %s.'</span> % self.name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">howMany</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''Prints the current population.'''</span></span><br><span class="line">        <span class="keyword">if</span> Person.population == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'I am the only person here.'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'We have %d persons here.'</span> % Person.population</span><br><span class="line">swaroop = Person(<span class="string">'Swaroop'</span>)</span><br><span class="line">swaroop.sayHi()</span><br><span class="line">swaroop.howMany()</span><br><span class="line">kalam = Person(<span class="string">'Abdul Kalam'</span>)</span><br><span class="line">kalam.sayHi()</span><br><span class="line">kalam.howMany()</span><br><span class="line">swaroop.sayHi()</span><br><span class="line">swaroop.howMany()</span><br></pre></td></tr></table></figure></p>
<p>　　在这个程序中，我们还看到docstring对于类和方法同样有用。我们可以在运行时使用Person.__doc__和Person.sayHi.__doc__来分别访问类与方法的文档字符串。<br>　　Python中所有的类成员(包括数据成员)都是公共的，所有的方法都是有效的。只有一个例外：如果你使用的数据成员名称以双下划线前缀比如__privatevar，Python的名称管理体系会有效地把它作为私有变量。</p>
<h1 id="继承">继承</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: inherit.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolMember</span>:</span></span><br><span class="line">    <span class="string">'''Represents any school member.'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'(Initialized SchoolMember: %s)'</span> % self.name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tell</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''Tell my details.'''</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Name:"%s" Age:"%s"'</span> % (self.name, self.age),</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span><span class="params">(SchoolMember)</span>:</span></span><br><span class="line">    <span class="string">'''Represents a teacher.'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, salary)</span>:</span></span><br><span class="line">        SchoolMember.__init__(self, name, age)</span><br><span class="line">        self.salary = salary</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'(Initialized Teacher: %s)'</span> % self.name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tell</span><span class="params">(self)</span>:</span></span><br><span class="line">        SchoolMember.tell(self)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Salary: "%d"'</span> % self.salary</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(SchoolMember)</span>:</span></span><br><span class="line">    <span class="string">'''Represents a student.'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, marks)</span>:</span></span><br><span class="line">        SchoolMember.__init__(self, name, age)</span><br><span class="line">        self.marks = marks</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'(Initialized Student: %s)'</span> % self.name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tell</span><span class="params">(self)</span>:</span></span><br><span class="line">        SchoolMember.tell(self)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Marks: "%d"'</span> % self.marks</span><br><span class="line">t = Teacher(<span class="string">'Mrs. Shrividya'</span>, <span class="number">40</span>, <span class="number">30000</span>)</span><br><span class="line">s = Student(<span class="string">'Swaroop'</span>, <span class="number">22</span>, <span class="number">75</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="comment"># prints a blank line</span></span><br><span class="line">members = [t, s]</span><br><span class="line"><span class="keyword">for</span> member <span class="keyword">in</span> members:</span><br><span class="line">    member.tell() <span class="comment"># works for both Teachers and Students</span></span><br></pre></td></tr></table></figure>
<p>　　为了使用继承，我们把基本类的名称作为一个元组跟在定义类时的类名称之后。如果在继承元组中列了一个以上的类，那么它就被称作多重继承 。</p>
<h1 id="文件">文件</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: using_file.py</span></span><br><span class="line">poem = <span class="string">'''\</span><br><span class="line">Programming is fun</span><br><span class="line">When the work is done</span><br><span class="line">if you wanna make your work also fun:</span><br><span class="line">use Python!</span><br><span class="line">'''</span></span><br><span class="line">f = file(<span class="string">'poem.txt'</span>, <span class="string">'w'</span>) <span class="comment"># open for 'w'riting</span></span><br><span class="line">f.write(poem) <span class="comment"># write text to file</span></span><br><span class="line">f.close() <span class="comment"># close the file</span></span><br><span class="line">f = file(<span class="string">'poem.txt'</span>)</span><br><span class="line"><span class="comment"># if no mode is specified, 'r'ead mode is assumed by default</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    line = f.readline()</span><br><span class="line">    <span class="keyword">if</span> len(line) == <span class="number">0</span>: <span class="comment"># Zero length indicates EOF</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">print</span> line,</span><br><span class="line"><span class="comment"># Notice comma to avoid automatic newline added by Python</span></span><br><span class="line">f.close() <span class="comment"># close the file</span></span><br></pre></td></tr></table></figure>
<p>　　在一个循环中，我们使用readline方法读文件的每一行。这个方法返回包括行末换行符的一个完整行。所以，当一个空的字符串被返回的时候，即表示文件末已经到达了，于是我们停止循环。<br>　　<strong>注意：</strong>因为从文件读到的内容已经以换行符结尾，所以我们在print语句上使用逗号来消除自动换行。最后，我们用close关闭这个文件。</p>
<h1 id="持久地储存对象">持久地储存对象</h1><p>　　Python提供一个标准的模块，称为pickle。使用它你可以在一个文件中储存任何Python对象，之后你又可以把它完整无缺地取出来。这被称为持久地储存对象。<br>　　还有另一个模块称为cPickle，它的功能和pickle模块完全相同，只不过它是用C语言编写的，因此要快得多(比pickle快1000倍)。你可以使用它们中的任一个，而我们在这里将使用cPickle模块。记住，我们把这两个模块都简称为pickle模块。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: pickling.py</span></span><br><span class="line"><span class="keyword">import</span> cPickle <span class="keyword">as</span> p</span><br><span class="line"><span class="comment">#import pickle as p</span></span><br><span class="line">shoplistfile = <span class="string">'shoplist.data'</span></span><br><span class="line"><span class="comment"># the name of the file where we will store the object</span></span><br><span class="line">shoplist = [<span class="string">'apple'</span>, <span class="string">'mango'</span>, <span class="string">'carrot'</span>]</span><br><span class="line"><span class="comment"># Write to the file</span></span><br><span class="line">f = file(shoplistfile, <span class="string">'w'</span>)</span><br><span class="line">p.dump(shoplist, f) <span class="comment"># dump the object to a file</span></span><br><span class="line">f.close()</span><br><span class="line"><span class="keyword">del</span> shoplist <span class="comment"># remove the shoplist</span></span><br><span class="line"><span class="comment"># Read back from the storage</span></span><br><span class="line">f = file(shoplistfile)</span><br><span class="line">storedlist = p.load(f)</span><br><span class="line"><span class="keyword">print</span> storedlist</span><br></pre></td></tr></table></figure></p>
<p>　　为了在文件里储存一个对象，首先以写模式打开一个file对象，然后调用储存器模块的dump函数，把对象储存到打开的文件中，这个过程称为储存。接下来，我们使用pickle模块的load函数的返回来取回对象，这个过程称为 取储存 。</p>
<h1 id="异常">异常</h1><h2 id="处理异常">处理异常</h2><p>　　我们可以使用try..except语句来处理异常。我们把通常的语句放在try-块中，而把我们的错误处理语句放在except-块中。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: try_except.py</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    s = raw_input(<span class="string">'Enter something --&gt; '</span>)</span><br><span class="line"><span class="keyword">except</span> EOFError:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\nWhy did you do an EOF on me?'</span></span><br><span class="line">    sys.exit() <span class="comment"># exit the program</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\nSome error/exception occurred.'</span></span><br><span class="line">    <span class="comment"># here, we are not exiting the program</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Done'</span></span><br></pre></td></tr></table></figure></p>
<p>　　你还可以让try..catch块关联上一个else从句，当没有异常发生的时候，else从句将被执行。</p>
<h2 id="引发异常">引发异常</h2><p>　　你可以使用raise语句引发异常，你还得指明错误/异常的名称和伴随异常触发的异常对象。你可以引发的错误或异常应该分别是一个Error或Exception类的直接或间接导出类。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: raising.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShortInputException</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="string">'''A user-defined exception class.'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, length, atleast)</span>:</span></span><br><span class="line">        Exception.__init__(self)</span><br><span class="line">        self.length = length</span><br><span class="line">        self.atleast = atleast</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    s = raw_input(<span class="string">'Enter something --&gt; '</span>)</span><br><span class="line">    <span class="keyword">if</span> len(s) &lt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">raise</span> ShortInputException(len(s), <span class="number">3</span>)</span><br><span class="line">    <span class="comment"># Other work can continue as usual here</span></span><br><span class="line"><span class="keyword">except</span> EOFError:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\nWhy did you do an EOF on me?'</span></span><br><span class="line"><span class="keyword">except</span> ShortInputException, x:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'ShortInputException: The input was of length %d, \</span><br><span class="line">was expecting at least %d'</span> % (x.length, x.atleast)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'No exception was raised.'</span></span><br></pre></td></tr></table></figure></p>
<h2 id="try-finally">try..finally</h2><p>　　假如你在读一个文件的时候，希望在无论异常发生与否的情况下都关闭文件，该怎么做呢？这可以使用finally块来完成。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: finally.py</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = file(<span class="string">'poem.txt'</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>: <span class="comment"># our usual file-reading idiom</span></span><br><span class="line">        line = f.readline()</span><br><span class="line">        <span class="keyword">if</span> len(line) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">print</span> line,</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">f.close()</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Cleaning up...closed the file'</span></span><br></pre></td></tr></table></figure></p>
<h1 id="Python标准库">Python标准库</h1><h2 id="sys模块-1">sys模块</h2><p>　　命令行参数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: cat.py</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readfile</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="string">'''Print a file to the standard output.'''</span></span><br><span class="line">    f = file(filename)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        line = f.readline()</span><br><span class="line">        <span class="keyword">if</span> len(line) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">print</span> line, <span class="comment"># notice comma</span></span><br><span class="line">    f.close()</span><br><span class="line"><span class="comment"># Script starts from here</span></span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &lt; <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'No action specified.'</span></span><br><span class="line">    sys.exit()</span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>].startswith(<span class="string">'--'</span>):</span><br><span class="line">    option = sys.argv[<span class="number">1</span>][<span class="number">2</span>:]</span><br><span class="line">    <span class="comment"># fetch sys.argv[1] but without the first two characters</span></span><br><span class="line">    <span class="keyword">if</span> option == <span class="string">'version'</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Version 1.2'</span></span><br><span class="line">    <span class="keyword">elif</span> option == <span class="string">'help'</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'''\</span><br><span class="line">This program prints files to the standard output.</span><br><span class="line">Any number of files can be specified.</span><br><span class="line">Options include:</span><br><span class="line">--version : Prints the version number</span><br><span class="line">--help : Display this help'''</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Unknown option.'</span></span><br><span class="line">        sys.exit()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> sys.argv[<span class="number">1</span>:]:</span><br><span class="line">        readfile(filename)</span><br></pre></td></tr></table></figure></p>
<h2 id="os模块">os模块</h2><p>　　使用os.sep可以取代操作系统特定的路径分割符。<br>　　os.name字符串指示你正在使用的平台。比如对于Windows,它是’nt’，而对于Linux/Unix用户，它是’posix’。<br>　　os.getcwd()函数得到当前工作目录，即当前Python脚本工作的目录路径。<br>　　os.getenv()和os.putenv()函数分别用来读取和设置环境变量。<br>　　os.listdir()返回指定目录下的所有文件和目录名。<br>　　os.remove()函数用来删除一个文件。<br>　　os.system()函数用来运行shell命令。<br>　　os.linesep字符串给出当前平台使用的行终止符。例如，Windows使用’\r\n’，Linux使用’\n’而Mac使用’\r’。<br>　　os.path.split()函数返回一个路径的目录名和文件名。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>os.path.split(<span class="string">'/home/swaroop/byte/code/poem.txt'</span>)</span><br><span class="line">(<span class="string">'/home/swaroop/byte/code'</span>, <span class="string">'poem.txt'</span>)</span><br></pre></td></tr></table></figure></p>
<p>　　os.path.isfile()和os.path.isdir()函数分别检验给出的路径是一个文件还是目录。类似地，os.<br>　　path.exists()函数用来检验给出的路径是否真地存在。</p>
<h1 id="更多Python知识">更多Python知识</h1><h2 id="列表综合">列表综合</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: list_comprehension.py</span></span><br><span class="line">listone = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">listtwo = [<span class="number">2</span>*i <span class="keyword">for</span> i <span class="keyword">in</span> listone <span class="keyword">if</span> i &gt; <span class="number">2</span>]</span><br><span class="line"><span class="keyword">print</span> listtwo</span><br></pre></td></tr></table></figure>
<p>　　当要使函数接收元组或字典形式的参数的时候，有一种特殊的方法，它分别使用*和**前缀。这种方法在函数需要获取可变数量的参数的时候特别有用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">powersum</span><span class="params">(power, *args)</span>:</span></span><br><span class="line"><span class="prompt">... </span><span class="string">'''Return the sum of each argument raised to specified power.'''</span></span><br><span class="line"><span class="prompt">... </span>total = <span class="number">0</span></span><br><span class="line"><span class="prompt">... </span><span class="keyword">for</span> i <span class="keyword">in</span> args:</span><br><span class="line">...</span><br><span class="line">total += pow(i, power)</span><br><span class="line"><span class="prompt">... </span><span class="keyword">return</span> total</span><br><span class="line">...</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>powersum(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>powersum(<span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure></p>
<p>　　由于在args变量前有*前缀，所有多余的函数参数都会作为一个元组存储在args中。如果使用的是**前缀，多余的参数则会被认为是一个字典的键/值对。</p>
<h2 id="lamda表达式">lamda表达式</h2><p>　　lambda语句被用来创建新的函数对象，并且在运行时返回它们。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: lambda.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_repeater</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> s: s*n</span><br><span class="line">twice = make_repeater(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">print</span> twice(<span class="string">'word'</span>)</span><br><span class="line"><span class="keyword">print</span> twice(<span class="number">5</span>)</span><br></pre></td></tr></table></figure></p>
<p>　　这里，我们使用了make_repeater函数在运行时创建新的函数对象，并且返回它。lambda语句用来创建函数对象。本质上，lambda需要一个参数，后面仅跟单个表达式作为函数体，而表达式的值被这个新建的函数返回。注意，即便是print语句也不能用在lambda形式中，只能使用表达式。</p>
<h2 id="exec和eval语句">exec和eval语句</h2><p>　　exec语句用来执行储存在字符串或文件中的Python语句。例如，我们可以在运行时生成一个包含Python代码的字符串，然后使用exec语句执行这些语句。eval语句用来计算存储在字符串中的有效Python表达式。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">exec</span> <span class="string">'print "Hello World"'</span></span><br><span class="line">Hello World</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>eval(<span class="string">'2*3'</span>)</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure></p>
<h2 id="assert语句">assert语句</h2><p>　　assert语句用来声明某个条件是真的。例如，如果你非常确信某个你使用的列表中至少有一个元素，而你想要检验这一点，并且在它非真的时候引发一个错误，那么assert语句是应用在这种情形下的理想语句。当assert语句失败的时候，会引发一个AssertionError。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; mylist = ['item']</span><br><span class="line">&gt;&gt;&gt; assert len(mylist) &gt;= 1</span><br><span class="line">&gt;&gt;&gt; mylist.pop()</span><br><span class="line">'item'</span><br><span class="line">&gt;&gt;&gt; assert len(mylist) &gt;= 1</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File "&lt;stdin&gt;", line 1, in ?</span><br><span class="line">AssertionError</span><br></pre></td></tr></table></figure></p>
<h2 id="repr函数">repr函数</h2><p>　　repr函数用来取得对象的规范字符串表示。反引号(也称转换符，键盘左上角esc下面的那个键)可以完成相同的功能。注意，在大多数时候有eval(repr(object)) == object。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>i = []</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>i.append(<span class="string">'item'</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>`i`</span><br><span class="line"><span class="string">"['item']"</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>repr(i)</span><br><span class="line"><span class="string">"['item']"</span></span><br></pre></td></tr></table></figure></p>
<p>[参考资料]</p>
<ol>
<li><a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/" target="_blank" rel="external">简明Python教程</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[前段时间看到v2和segment上有人谈论Django，就去查了一下，原来是基于Python的开源框架，再加上我早就想学习Python了，最近比较闲，正好就开始了Python的学习，最近看了一个比较入门级别的教程，名为：简明Python教程，学习之余就把一些知识点记录了下来以便复习只用。还有，我发现云课堂上的有一个Python视频课就是按照这本教程来讲解的。]]>
    
    </summary>
    
      <category term="Python" scheme="https://ningban.github.io/tags/Python/"/>
    
      <category term="Python" scheme="https://ningban.github.io/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[11]贝叶斯统计正则化]]></title>
    <link href="https://ningban.github.io/2015/01/21/-11-%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BB%9F%E8%AE%A1%E6%AD%A3%E5%88%99%E5%8C%96/"/>
    <id>https://ningban.github.io/2015/01/21/-11-贝叶斯统计正则化/</id>
    <published>2015-01-21T07:51:52.000Z</published>
    <updated>2015-03-08T13:23:32.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-11-1.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-11-2.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-11-3.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-11-4.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-11-5.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-11-6.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-11-7.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-11-8.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-11-9.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-11-10.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-11-11.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-11-12.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-11-13.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-11-14.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-11-15.jpg" alt="图2-18"></p>
<p>[参考资料]</p>
<ol>
<li><a href="http://v.163.com/movie/2008/1/L/M/M6SGF6VB4_M6SGKG5LM.html" target="_blank" rel="external">斯坦福大学公开课 ：机器学习课程</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[本节首先介绍了贝叶斯统计和规范化；之后简单介绍了在线学习的概念；之后介绍了机器学习算法设计中的问题诊断技巧；之后介绍了两种分析技巧：误差分析与销蚀分析；最后介绍了两种应用机器学习算法的方式与使用。]]>
    
    </summary>
    
      <category term="机器学习" scheme="https://ningban.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Machine Learning" scheme="https://ningban.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[10]特征选择]]></title>
    <link href="https://ningban.github.io/2015/01/18/-10-%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9/"/>
    <id>https://ningban.github.io/2015/01/18/-10-特征选择/</id>
    <published>2015-01-18T08:12:56.000Z</published>
    <updated>2015-03-19T06:22:03.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-10-1.jpg" alt="图10-1"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-10-2.jpg" alt="图10-2"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-10-3.jpg" alt="图10-3"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-10-4.jpg" alt="图10-4"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-10-5.jpg" alt="图10-5"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-10-6.jpg" alt="图10-6"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-10-7.jpg" alt="图10-7"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-10-8.jpg" alt="图10-8"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-10-9.jpg" alt="图10-9"></p>
<p>[参考资料]</p>
<ol>
<li><a href="http://v.163.com/movie/2008/1/U/O/M6SGF6VB4_M6SGJURUO.html" target="_blank" rel="external">斯坦福大学公开课 ：机器学习课程</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[本节首先介绍了VC维的概念——该概念能够将关于ERM一般误差的界的结论推广到无限假设类的情形；之后介绍了模型选择问题——具体介绍了交叉验证方法以及几种变形；最后介绍了特征选择问题——具体介绍了两类方法：封装特征选择和过滤特征选择。]]>
    
    </summary>
    
      <category term="机器学习" scheme="https://ningban.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Machine Learning" scheme="https://ningban.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[9]经验风险最小化ERM]]></title>
    <link href="https://ningban.github.io/2015/01/17/-9-%E7%BB%8F%E9%AA%8C%E9%A3%8E%E9%99%A9%E6%9C%80%E5%B0%8F%E5%8C%96ERM/"/>
    <id>https://ningban.github.io/2015/01/17/-9-经验风险最小化ERM/</id>
    <published>2015-01-17T07:18:16.000Z</published>
    <updated>2015-03-08T13:22:43.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-9-1.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-9-2.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-9-3.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-9-4.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-9-5.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-9-6.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-9-7.jpg" alt="图2-18"></p>
<p>[参考资料]</p>
<ol>
<li><a href="http://v.163.com/movie/2008/1/F/H/M6SGF6VB4_M6SGJV3FH.html" target="_blank" rel="external">斯坦福大学公开课 ：机器学习课程</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[本节主要介绍了模型选择中的一种常见现象——偏差方差权衡。为了解释该概念，首先介绍了两个重要的引理——联合届引理和Hoeffding不等式，之后定义了两个重要的概念——训练误差和一般误差，并提出了一种简化的机器学习算法模型——经验风险最小化ERM。最后基于这些该你那对ERM结果的理论上界进行了证明，并基于上界分析对偏差方差权衡进行了解释。]]>
    
    </summary>
    
      <category term="机器学习" scheme="https://ningban.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Machine Learning" scheme="https://ningban.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[8]顺序最小优化算法]]></title>
    <link href="https://ningban.github.io/2015/01/16/-8-%E9%A1%BA%E5%BA%8F%E6%9C%80%E5%B0%8F%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"/>
    <id>https://ningban.github.io/2015/01/16/-8-顺序最小优化算法/</id>
    <published>2015-01-16T05:52:14.000Z</published>
    <updated>2015-03-08T13:22:29.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-8-1.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-8-2.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-8-3.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-8-4.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-8-5.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-8-6.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-8-7.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-8-8.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-8-9.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-8-10.jpg" alt="图2-18"></p>
<p>[参考资料]</p>
<ol>
<li><a href="http://v.163.com/movie/2008/1/9/3/M6SGF6VB4_M6SGJVA93.html" target="_blank" rel="external">斯坦福大学公开课 ：机器学习课程</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[本节首先介绍了核的概念——它在SVM以及许多学习算法中都有重要的应用，之后介绍了L1 norm软间隔SVM——它使用SVM的变化形式，可以处理非线性可分隔的数据，最后介绍了SMO算法——一种高效的可以解决SVM优化问题的算法。]]>
    
    </summary>
    
      <category term="机器学习" scheme="https://ningban.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Machine Learning" scheme="https://ningban.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[闲中作画]]></title>
    <link href="https://ningban.github.io/2015/01/16/%E9%97%B2%E4%B8%AD%E6%B6%82%E9%B8%A6/"/>
    <id>https://ningban.github.io/2015/01/16/闲中涂鸦/</id>
    <published>2015-01-16T05:44:05.000Z</published>
    <updated>2015-03-08T12:58:29.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7vihec.com1.z0.glb.clouddn.com/yiqiko.png" alt="黑崎一护"></p>
]]></content>
    <summary type="html">
    <![CDATA[一护参上]]>
    
    </summary>
    
      <category term="Life" scheme="https://ningban.github.io/tags/Life/"/>
    
      <category term="Life" scheme="https://ningban.github.io/categories/Life/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[7]最优间隔分类器]]></title>
    <link href="https://ningban.github.io/2015/01/15/-7-%E6%9C%80%E4%BC%98%E9%97%B4%E9%9A%94%E5%88%86%E7%B1%BB%E5%99%A8/"/>
    <id>https://ningban.github.io/2015/01/15/-7-最优间隔分类器/</id>
    <published>2015-01-15T10:00:03.000Z</published>
    <updated>2015-03-08T13:22:10.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-7-1.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-7-2.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-7-3.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-7-4.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-7-5.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-7-6.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-7-7.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-7-8.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-7-9.jpg" alt="图2-18"></p>
<p>[参考资料]</p>
<ol>
<li><a href="http://v.163.com/movie/2008/1/C/6/M6SGF6VB4_M6SGJVMC6.html" target="_blank" rel="external">斯坦福大学公开课 ：机器学习课程</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[本节首先提出了原始的最优化问题：最优间隔分类器问题，之后介绍了对偶问题的概念和KKT条件，之后基于原始优化问题的对偶问题的分析，介绍了SVM算法。课程的最后对SVM算法进行了评价，以引出下节课对核方法的介绍。]]>
    
    </summary>
    
      <category term="机器学习" scheme="https://ningban.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Machine Learning" scheme="https://ningban.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[打发悲伤的涂鸦]]></title>
    <link href="https://ningban.github.io/2015/01/15/%E6%89%93%E5%8F%91%E6%82%B2%E4%BC%A4%E7%9A%84%E6%B6%82%E9%B8%A6/"/>
    <id>https://ningban.github.io/2015/01/15/打发悲伤的涂鸦/</id>
    <published>2015-01-15T09:31:31.000Z</published>
    <updated>2015-03-08T13:01:06.000Z</updated>
    <content type="html"><![CDATA[<p>　　人生不如意十有八九，最近我不小心误入八九之中，现在终于出来了。虽然我们都挺讨厌八九的，但是我挺感谢它的，因为它让我领悟到了“命中注定”（失败者的托词），领悟到了“行百里者半九十”，领悟到了“好了伤疤忘了疼”，领悟到了“书读太少，想太多”，领悟到了“受尽苦难而不厌，此乃修罗之道”。来，看下阴转悲伤的天气：<br><img src="http://7vihec.com1.z0.glb.clouddn.com/sad.png" alt="阴转sadness的心情"></p>
]]></content>
    <summary type="html">
    <![CDATA[命运（日语叫unmei）、行百里者半九十]]>
    
    </summary>
    
      <category term="Life" scheme="https://ningban.github.io/tags/Life/"/>
    
      <category term="Life" scheme="https://ningban.github.io/categories/Life/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[6]朴素贝叶斯算法]]></title>
    <link href="https://ningban.github.io/2015/01/12/-6-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95/"/>
    <id>https://ningban.github.io/2015/01/12/-6-朴素贝叶斯算法/</id>
    <published>2015-01-12T12:17:50.000Z</published>
    <updated>2015-03-08T13:21:48.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-6-1.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-6-2.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-6-3.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-6-4.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-6-5.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-6-6.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-6-7.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-6-8.jpg" alt="图2-18"></p>
<p>[参考资料]</p>
<ol>
<li><a href="http://v.163.com/movie/2008/1/7/H/M6SGF6VB4_M6SGJVV7H.html" target="_blank" rel="external">斯坦福大学公开课 ：机器学习课程</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[本节首先介绍了两种朴素贝叶斯算法的时间模型，之后介绍了神经网络算法，并在最后介绍了两个重要的概念：函数间隔和几何间隔，基于这两个概念提出了一个线性分类算法：最大间隔分类器算法。该算法用于引出一个非常重要的非线性分类算法：支持向量机SVM。]]>
    
    </summary>
    
      <category term="机器学习" scheme="https://ningban.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Machine Learning" scheme="https://ningban.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[5]生成学习算法]]></title>
    <link href="https://ningban.github.io/2015/01/11/-5-%E7%94%9F%E6%88%90%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/"/>
    <id>https://ningban.github.io/2015/01/11/-5-生成学习算法/</id>
    <published>2015-01-11T10:43:31.000Z</published>
    <updated>2015-03-08T13:21:25.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-5-1.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-5-2.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-5-3.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-5-4.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-5-5.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-5-6.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-5-7.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-5-8.jpg" alt="图2-18"></p>
<p>[参考资料]</p>
<ol>
<li><a href="http://v.163.com/movie/2008/1/A/R/M6SGF6VB4_M6SGHMFAR.html" target="_blank" rel="external">斯坦福大学公开课 ：机器学习课程</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[本课首先介绍了一类新的学习算法——生成学习算法，并详细介绍了该算法的一个例子：高斯判别分析；之后对生成学习算法与之前的判别学习算法进行对比；最后介绍了一个合适对文本进行分类的算法——朴素贝叶斯算法，并结合该算法介绍了一种常用的平滑技术——Lapace平滑。]]>
    
    </summary>
    
      <category term="机器学习" scheme="https://ningban.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Machine Learning" scheme="https://ningban.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[洋为中用]]></title>
    <link href="https://ningban.github.io/2015/01/10/%E6%B4%8B%E4%B8%BA%E4%B8%AD%E7%94%A8/"/>
    <id>https://ningban.github.io/2015/01/10/洋为中用/</id>
    <published>2015-01-10T03:49:16.000Z</published>
    <updated>2015-03-08T12:53:07.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7vihec.com1.z0.glb.clouddn.com/thinking.jpeg" alt="浩瀚的宇宙"><br>　　昨天老师关于论文开了一个会，会上的一句话令我颇为震撼。“不管是做学术还是其他，老外基本上总是走在最前方，国内都是copy其思想或者模式，继而找到适合中国特色的道路。如百度与Google，阿里巴巴与亚马逊等。同样，在学术方面基本也是如此，所以要习惯看英文文章，这样才可以接触最前沿的东西。”其实却是是这样，现在国内的互联网公司的模式大多是都是从国外借鉴过来的，比如最近的打车应用就是师从Uber，在线教育就是师从Coursera。我对老师的话语产生共鸣的原因有二：一是我虽然也有同样的想法，但是我从来没有像他这样总结成章，所以平常的我缺乏思考（ps：学而不思则罔，思而不学则殆）；二，即使我也像老师那样总结成章，但我也不会把这套理论应用于学术方面，所以平常的我思维不够发散与活跃，不懂得举一反三。<br>　　在会上，当我提到Stanford的机器学习视频的时候，老师也赞同现在的在线教育之火热，并且建议我们到<a href="http://www.mooc.cn/" target="_blank" rel="external">MOOC</a>上去学习。MOOC这个课程网站之前我再<a href="https://www.v2ex.com/?r=Jning" target="_blank" rel="external">v2ex</a>上看到过，知道它是一个公开课平台，这次之后特地查了一下，确实不错，有很多国内外名校的课程都放在了上面，我们可以自行去学习，以后我也会经常去逛一逛。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7vihec.com1.z0.glb.clouddn.com/thinking.jpeg" alt="浩瀚的宇宙"><br>　　昨天老师关于论文开了一个会，会上的一句话令我颇为震撼。“不管是做学术还是其他，老外基本上总是走在最前方，国内都是]]>
    </summary>
    
      <category term="分享与发现" scheme="https://ningban.github.io/tags/%E5%88%86%E4%BA%AB%E4%B8%8E%E5%8F%91%E7%8E%B0/"/>
    
      <category term="分享与发现" scheme="https://ningban.github.io/categories/%E5%88%86%E4%BA%AB%E4%B8%8E%E5%8F%91%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[4]牛顿方法]]></title>
    <link href="https://ningban.github.io/2015/01/09/-4-%E7%89%9B%E9%A1%BF%E6%96%B9%E6%B3%95/"/>
    <id>https://ningban.github.io/2015/01/09/-4-牛顿方法/</id>
    <published>2015-01-09T05:23:56.000Z</published>
    <updated>2015-03-08T13:20:58.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-4-1.png" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-4-2.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-4-3.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-4-4.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-4-5.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-4-6.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-4-7.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-4-8.jpg" alt="图2-18"></p>
<p>[参考资料]</p>
<ol>
<li><a href="http://v.163.com/movie/2008/1/E/D/M6SGF6VB4_M6SGHKAED.html" target="_blank" rel="external">斯坦福大学公开课 ：机器学习课程</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[本节首先介绍了牛顿方法，可以替代梯度上升算法用来计算函数的最大值；之后以高斯分布和伯努利分布为例介绍了指数分布函数族；最后一指数分布函数族作为基础，引出了广义线性模型，可以通过指定概率分布直接推导出模型。]]>
    
    </summary>
    
      <category term="机器学习" scheme="https://ningban.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Machine Learning" scheme="https://ningban.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[3]欠拟合与过拟合]]></title>
    <link href="https://ningban.github.io/2015/01/08/-3-%E6%AC%A0%E6%8B%9F%E5%90%88%E4%B8%8E%E8%BF%87%E6%8B%9F%E5%90%88/"/>
    <id>https://ningban.github.io/2015/01/08/-3-欠拟合与过拟合/</id>
    <published>2015-01-08T12:12:45.000Z</published>
    <updated>2015-03-08T13:20:28.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-3-1.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-3-2.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-3-3.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-3-4.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-3-5.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-3-6.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-3-7.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-3-8.jpg" alt="图2-18"></p>
<p>[参考资料]</p>
<ol>
<li><a href="http://v.163.com/movie/2008/1/E/B/M6SGF6VB4_M6SGHM4EB.html" target="_blank" rel="external">斯坦福大学公开课 ：机器学习课程</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[欠拟合与过拟合的概念，参数化即非参数化算法概念，局部加权回归，对于线性模型的概率解释，Logistic回归，感知器...]]>
    
    </summary>
    
      <category term="机器学习" scheme="https://ningban.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Machine Learning" scheme="https://ningban.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[2]监督学习应用.梯度下降]]></title>
    <link href="https://ningban.github.io/2015/01/08/-2-%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E5%BA%94%E7%94%A8-%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"/>
    <id>https://ningban.github.io/2015/01/08/-2-监督学习应用-梯度下降/</id>
    <published>2015-01-08T05:23:54.000Z</published>
    <updated>2015-03-08T13:17:22.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-2-1.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-2-2.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-2-3.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-2-4.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-2-5.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-2-6.jpg" alt="图2-18"><br><img src="http://7vihec.com1.z0.glb.clouddn.com/ml-2-7.jpg" alt="图2-18"></p>
<p>[参考资料]</p>
<ol>
<li><a href="http://v.163.com/movie/2008/1/B/O/M6SGF6VB4_M6SGHJ9BO.html" target="_blank" rel="external">斯坦福大学公开课 ：机器学习课程</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[监督学习应用——自助推导，ALVNN系统，线性回归，梯度下降，批梯度下降，随机梯度下降...]]>
    
    </summary>
    
      <category term="机器学习" scheme="https://ningban.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Machine Learning" scheme="https://ningban.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[随笔于20150108]]></title>
    <link href="https://ningban.github.io/2015/01/08/%E9%9A%8F%E7%AC%94%E4%BA%8E20150108/"/>
    <id>https://ningban.github.io/2015/01/08/随笔于20150108/</id>
    <published>2015-01-08T04:28:58.000Z</published>
    <updated>2015-01-10T04:16:33.000Z</updated>
    <content type="html"><![CDATA[<p>　　好久没有写博客了，有几方面的原因：首先，就是自己没有坚持写博客，也就是自己毅力不给力啊；然后，就是最近有点别的事情在忙，当然既有正事也有玩的事情。<br>　　一晃一年就这样过去了，好快（ps：日语叫做哈压抑）啊！看到很多人都在写自己的2014年终总结，还有2015年计划，自己也有点小激动，虽然一年也没有什么作为，但是还是写了，只不过是没有公开。昨天练完车回来之后，突然意识到我好久没有写什么东西了，但是又没有什么可以写的，就开始看Stanford的机器学习教学视频，这个视频讲的非常好，虽然我也没听太懂，也是云里雾里的，但是还在坚持看。视频里的老师就是上一年加入百度的牛人Andrew NG，现在加入百度，负责“百度大脑”，以前在google，同时他也是在线教育Coursera的创始人哦。他不仅学术做的好，课讲的也相当不错哦，所以视频相当值得一看！在看视频的过程中，当然我也做了一些笔记（ps:所谓的笔记，也不过是把他写在黑板上的东西copy了一遍而已），于是乎，我就想我过年回家的是时候怎么看我做过的笔记啊，难道要把note拿回家，估计拿了也不会看吧。所以，我就想是不是可以把这些笔记拍成照片放在我的博客里呢，这样的话，只要有网络我就可以看看笔记了，于是我就来这里瞎写来了。对于我学习机器学习的原因呢，大约有这几个原因：首先，这不，快要毕业了嘛，论文是关于机器学习的，所以就开始学习机器学习喽；其次呢，就是我曾经发表过一篇关于信息抽取的文章（ps：很水的文章啦，无视吧），里面用到机器学习的算法，所以我想再更深入的了解一下机器学习，说不定未来的工作会用到机器学习，或者自己一下子会喜欢上了这个高大上的方向呢。好了，废话就不说太多了，接下来的n多篇文章应该都是视频里的笔记，我可能会在看完这个视频之后，还是看一下加州理工的机器学习视频，笔记也会一并发布在这里吧。他们都是网易公开课里面的视频，我会把视频链接地址写在接下来的参考文献里面。</p>
<p>[参考资料]</p>
<ol>
<li><a href="http://v.163.com/special/opencourse/machinelearning.html" target="_blank" rel="external">斯坦福大学公开课 ：机器学习课程</a></li>
<li><a href="http://v.163.com/special/opencourse/learningfromdata.html9" target="_blank" rel="external">加州理工学院公开课：机器学习与数据挖掘</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　好久没有写博客了，有几方面的原因：首先，就是自己没有坚持写博客，也就是自己毅力不给力啊；然后，就是最近有点别的事情在忙，当然既有正事也有玩的事情。<br>　　一晃一年就这样过去了，好快（ps：日语叫做哈压抑）啊！看到很多人都在写自己的2014年终总结，还有2015年计划]]>
    </summary>
    
      <category term="机器学习" scheme="https://ningban.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Machine Learning" scheme="https://ningban.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Modern OS第2章之线程]]></title>
    <link href="https://ningban.github.io/2014/12/01/Modern-OS%E7%AC%AC2%E7%AB%A0%E4%B9%8B%E7%BA%BF%E7%A8%8B/"/>
    <id>https://ningban.github.io/2014/12/01/Modern-OS第2章之线程/</id>
    <published>2014-12-01T06:33:07.000Z</published>
    <updated>2015-03-08T13:12:46.000Z</updated>
    <content type="html"><![CDATA[<h1 id="线程的使用">线程的使用</h1><p>　　为什么人们需要在一个进程中再有一类进程？有若干理由说明产生这些mini进程（称为线程）的必要性。下面我们来讨论其中一些理由。</p>
<blockquote>
<ul>
<li>人们需要多线程的主要原因是，在许多应用中同时发生着多种活动。其中某些活动随着时间的推移会被阻塞。通过将这些应用程序分解成可以准并行运行的多个顺序线程，程序设计模型会变得更简单。</li>
<li>由于线程比进程更轻量级，所以它们比进程更容易（即更快）创建，也更容易撤销。在许多系统中，创建一个线程叫创建一个进程要快10-100倍。在有大量线程需要动态和快速修改时，具有这一特性是很有用的。</li>
<li>需要多线程的第三个原因涉及性能方面的讨论。若多线程都是CPU密集型的，那么并不能获得性能上的增强，但是如果存在着大量的计算和大量的I/O处理，拥有多个线程允许这些活动彼此重叠进行，从而会加快应用程序执行的速度。</li>
<li>最后，在多CPU系统中，多线程是有益的，在这样的系统中，真正的并行有了实现的可能。</li>
</ul>
</blockquote>
<h1 id="经典的线程模型">经典的线程模型</h1><p>　　进程模型基于两个独立的概念：资源分组处理与执行。<br>　　理解进程的一个角度是，用某种方法把相关的资源集中在一起。进程有存放程序正文和数据以及其他资源的地址空间。这些资源中包括打开的文件、子进程、即将发生的警报、信号处理程序、账号信息等。把它们都放到进程中可以更容易管理。</p>
<h2 id="进程与线程">进程与线程</h2><p>　　另一个概念是，进程拥有一个执行的线程，通常简写为线程（thread）。在线程中有一个程序计数器，用来记录接着要执行哪一条指令。线程拥有寄存器，用来保存线程当前的工作变量。线程还拥有一个堆栈，用来记录执行历史，其中每一帧保存了一个已调用的但是还没有从中返回的过程。尽管线程必须在某个进程中执行，但是线程和它的进程是不同的概念，并且可以分别处理。进程用于把资源集中到一起，而线程则是在CPU上被调度执行的实体。<br>　　线程给进程模型增加了一项内容，即在同一个进程环境中，允许彼此之间有较大独立性的线程执行。在同一个进程中并行运行多个线程，是对在同一台计算机上并行运行多个进程的模拟。在前一种情形下，多个线程共享同一个地址空间和其他资源。而在后一种情形中，多个进程共享物理内存、磁盘、打印机和其他资源。由于线程具有进程的某些性质，所以有时被称为<code>轻量级进程</code>（lightweight process）。多线程这个术语，也用来描述在同一个进程中允许多个线程的情形。<br>　　在图2-11a中，可以看到三个传统的进程。每个进程有自己的地址空间和单个控制线程。相反，在图2-11b中，可以看到一个进程带有三个传统的进程。尽管在两种情形中都有三个线程，但是在图2-11a中每个线程都在不同的地址空间中运行，而在图2-11b中，这三个线程全部在相同的地址空间中运行。<br><img src="http://7vihec.com1.z0.glb.clouddn.com/os20141202-1.png" alt="图2-11"></p>
<p>　　当多线程进程在单CPU系统中运行时，线程轮流运行。在图2-1中，我们已经看到了进程的多道程序设计师如何工作的。通过在多个进程之间来回切换，系统制造了不同的顺序进程并行运行的假象。多线程的工作方式也是类似的。CPU在线程之间的快速切换，制造了线程并行运行的假象，好似他们在一个比实际CPU慢一些的CPU上同时运行。在一个有三个计算密集型线程的进程中，线程以并行方式运行，每个线程在一个CPU上得到了真实CPU速度的三分之一。<br>　　进程中的不同线程不像不同进程之间那样存在很大的独立性。所有的线程都有完全一样的地址空间，这意味着它们也共享同样的全局变量。由于各个线程都可以访问进程地址空间中的每个内存地址，所以一个线程可以读、写或甚至清除另一个线程的堆栈。线程之间是没有保护的，原因是1）不可能，2）也没必要。这与不同进程是有差别的。不同的进程会来自不同的用户，他们彼此之间可能有敌意。一个进程总是由某个用户拥有，该用户创建多个线程应该是为了它们之间的合作而不是彼此间争斗。除了共享地址空间之外，所有线程还共享同一个打开文件集、子进程、报警以及相关信号等，如图2-12所示。这样，对于三个没有关系的进程而言，应该是用图2-11a的结构，而在三个线程实际完成同一个作业，并彼此积极密切合作的情形中，图2-11b则比较合适。<br><img src="http://7vihec.com1.z0.glb.clouddn.com/os20141202-2.png" alt="图2-12"></p>
<p>　　图2-12中，第一列表项是进程的属性，而不是线程的属性。例如，如果一个线程打开了一个文件，该文件对该进程中的其他线程都可见，这些线程可以对该文件进行读写。由于资源管理的单位是进程而非线程，所以这种情形是合理的。如果每个线程都有其自己的地址空间、打开文件、即将发生的报警等，那么它们就应该是不同的进程了。线程概念视图实现的是，共享一组资源的多个线程的执行能力，以便这些线程可以为完成某一任务而共同工作。<br>　　和传统进程一样，线程可以处于若干种状态的任何一个：运行、阻塞、就绪或终止。正在运行的线程拥有CPU并且是活跃的。被阻塞的线程正在等待某个释放它的事件。例如，当一个线程执行从键盘读入数据的系统调用时，该线程就被阻塞直到键入了输入为止。线程可以被阻塞，以便等待某个外部事件的发生或者等待其他线程来释放它。就绪线程可被调度运行，并且只要轮到它就很快可以运行。线程状态之间的转换和进程状态之间的转换是一样的。<br>　　认识到每个线程都有其自己的堆栈很重要，如图2-13所示。每个线程的堆栈有一帧，供各个被调用但是还没有从中返回的过程使用。在该帧中存放了相应的过程的局部变量以及过程调用完成之后使用的返回地址。例如，如果过程X调用过程Y，而Y又调用Z，那么当Z执行时，供X、Y和Z使用的帧会全部存在堆栈中。通常每个线程会调用不同的过程，从而有一个各自不同的执行理事。这就是为什么每个线程需要有自己的堆栈的原因。<br><img src="http://7vihec.com1.z0.glb.clouddn.com/os20141202-3.png" alt="图2-12"></p>
<blockquote>
<p>　　<code>简而言之，一个程序至少有一个进程，一个进程至少有一个线程。</code></p>
</blockquote>
<h2 id="多线程">多线程</h2><p>　　在多线程的情况下，进程通常会从当前的单个线程开始。这个线程有能力通过调用一个库函数（如thread_create）创建新的线程。thread_create的参数专门指定了新线程要运行的过程名。这里，没有必要对新线程的地址空间加以规定，因为新线程会自动在创建线程的地址空间中运行。有时，线程是有层次的，它们具有一种父子关系，但是，通常不存在这样一种关系，所有的线程都是平等的。不论有无层次关系，创建线程通常都返回一个线程的标识符，该标识符就是新线程的名字。<br>　　当一个线程完成工作后，可以通过调用一个库过程（如thrad_exit）退出，该线程接着消失，不再可调度。在某些线程系统中，通过调用一个过程，例如thread_join，一个线程可以等待一个（特定）线程退出。这个过程阻塞调用线程直到那个（特定）线程退出。在这种情况下，线程的创建和终止非常类似于进程的创建和终止，并且也有着同样的选项。<br>　　另外一个常见的线程调用是thread_yield，它允许线程自动放弃CPU从而让另一个线程运行。这样一个调用是很重要的，因为不同于进程，（线程库）无法利用时钟中单强制线程染出CPU。所以设法使线程行为“高尚”起来，并且随着时间的推移自动交出CPU，以便让其他线程有机会运行，就变得非常重要。有的调用允许某个线程等待另一个线程完成某些任务，或等待一个线程宣城它已经完成了有关的工作等。</p>
<h2 id="多线程带来的问题">多线程带来的问题</h2><p>　　通常而言，线程是有益的，但是线程也在程序设计模式中引入了某种程度的复杂性。考虑一下UNIX中fork系统调用，如果父进程有多个线程，那么它的子进程也应该拥有这些线程吗？如果不是，则改子进程可能会工作不正常，因为在该子进程中的线程都是绝对必要的。<br>　　然而，如果子进程拥有了与父进程一样的多个线程，如果父进程在read系统调用（比如键盘）上被阻塞了会发生什么情况？是两个线程被阻塞在键盘上（一个属于父进程，另一个属于子进程）吗？在键入一行输入之后，这两个进程都得到该输入的副本吗？还是仅有父进程得到该输入的副本？或是仅有子进程得到？类似的问题在进行网络连接时也会出现。<br>　　另一类问题和线程共享许多数据结构的事实有关。如果一个线程关闭了某个文件，而另一个线程还在该文件上进行读操作时会怎样？假设有一个线程注意到几乎没有内存了，并且也开始分配更多的内存。在工作一半的时候，发生线程切换，新线程也注意到几乎没有内存了，并且也开始分配更多的内存。这样，内存可能会分配两次。不过这些问题通过努力是可以解决的。总之，要使多线程的程序正确工作，就需要仔细思考和设计。</p>
<h1 id="POSIX线程">POSIX线程</h1><p>　　为了实现可一直的线程程序，IEEE在IEEE标砖1003.1c中定义了线程的标准。它定义的线程包叫做Pthread。大部分UNIX系统都支持该标准。这个标准定义了超过60个函数调用，如果在这里列举一遍就太多了。取而代之，我们将仅仅描述一些主要的函数，以说明它是如何工作的。图2-14中列举了这些函数调用。<br>　　所有Pthread线程都有某些特性。每一个都含有一个标识符、一组寄存器（包括程序计数器）和一组存储在结构中的属性。这些属性包括堆栈大小、调度参数以及使用线程需要的其他项目。<br><img src="http://7vihec.com1.z0.glb.clouddn.com/os20141202-4.png" alt="图2-14"></p>
<p>　　这里有两个线程调用是处理属性的。Pthread_attr_init建立关联一个线程的属性结构并初始化为默认值。这些值（例如优先级）可以通过修改属性结构中的值域来改变。pthread_attr_destroy删除一个线程的属性结构，释放它占用的内存。它不会影响调用它的线程。这些线程会继续存在。</p>
<h1 id="线程的实现">线程的实现</h1><p>　　有两种主要的方法实现线程包：在用户空间中和在内核中。这两种方法互有利弊，不过混合实现方式也是可能的。我们现在介绍这些方法并分析它们的优缺点。</p>
<h2 id="在用户空间中实现线程">在用户空间中实现线程</h2><p>　　第一种方式是把整个线程包放在用户空间中，内核对线程包一无所知。从内核角度考虑，就是按正常的方式管理，即单线程进程。这种方法第一个，也是最明显的优点是，用户级线程包可以在不支持线程的操作系统上实现。<br>　　所有的这类实现都有同样的通用结构，如图2-16a所示。线程在一个运行时系统的顶部运行，这个<code>运行时系统</code>是一个管理线程的过程的集合。我们已经见过其中的四个过程：pthread_create、pthread_exit、pthread_join和pthread_yield。不过一般还会有更多的过程。<br><img src="http://7vihec.com1.z0.glb.clouddn.com/os20141202-5.png" alt="图2-16"></p>
<p>　　在用户空间管理线程时，每个进程需要有其专用的线程表（thread table），用来跟踪该进程中的线程。这些表和内核中的进程表类似，不过它仅仅记录各个线程的属性，每个线程的程序计数器、堆栈指针、寄存器和状态。该线程表由运行时系统管理。当一个线程转换到就绪状态或阻塞状态时，在该线程表中存放重新启动该线程所需要的信息，与内核在进程表中存放进程的信息完全一样。<br>　　当某个线程做了一些会引起在本地阻塞的事情之后，例如，等待进程中另一个线程完成某项工作，它调用一个运行时系统的过程，这个过程检查该线程是否必须进入阻塞状态。如果是，它在线程表中保存该线程的寄存器（即它本身的），查看表中可运行的就绪线程，并把新线程的保存值重新装入机器的寄存器中。只要堆栈指针和程序计数器一被切换，新的吸纳成就又自动投入运行。如果机器有一条保存所有寄存器的指令和另一条装入全部寄存器的指令，那么整个线程的切换可以再几条指令内完成。进行类似于这样的线程切换至少必陷入内核要快一个数量级（或许更多），这是使用用户级线程包的极大的优点。<br>　　不过，线程与进程有一个关键的差别。在线程完成运行时，例如，在它调用thread_yield时，pthread_yield代码可以把该线程的信息保存在线程表中，进而，它可以调用<code>线程调度程序</code>来选择另一个要运行的线程。保存该线程状态的过程和调度程序都只是本地过程，所以启动它们比进行讷河调用效率更高。另一方面，不需要陷阱，不需要上下文切换，也不需要对内存高速缓存刷新，这就是使得线程调度非常快捷。<br>　　用户级线程还有另一个优点。它允许每个进程有自己定制的调度算法。例如，在某些应用程序中，那些有垃圾手机线程的应用程序就不用担心会在不合适的时刻停止，这是一个长处。用户级线程还具有较好的可扩展性，这是因为在内核空间中内核线程需要一些固定表格空间和堆栈空间，如果内核线程的数量非常大，就会出现问题。<br>　　尽管用户级线程包邮更好的性能，但它也存在一些明显的问题。其中第一个问题就是如何实现阻塞系统调用？假设在还没有任何击键之前，一个线程读取键盘。让该线程实际进行该系统调用是不可接受的，因为这会停止所有的线程。<br>　　有一种可能的替代方案，就是如果某个调用会阻塞，就提前通知。在某些UNIX版本中，有一个系统调用select可以允许调用者通知预期的read是否会阻塞。若有这个调用，那么库过程read就可以被新的操作替代，首先进行select调用，然后只有在安全的情形下（即不会阻塞）才进行read调用。如果read调用会被阻塞，有关的调用就不进行，代之以运行另一个线程。在系统调用从事检察的这类代码称为<code>包装器</code>（jacket或wrapper）。<br>　　与阻塞系统调用问题有些类似的是页面故障问题。如果某个程序调用或者跳转到了一条不在内存的指令上，就会发生页面故障，而操作系统降到磁盘上取回这个丢失的指令，这就称为<code>页面故障</code>。在对所需要的指令进行定位和读入时，相关的进程就被阻塞。如果有一个线程引起页面故障，内核由于甚至不知道有线程存在，通常把整个进程阻塞直到硬盘I/O完成为止，尽管其他的线程是可以运行的。<br>　　用户级线程包的另一个问题是，如果一个线程开始运行，那么在该进程中的其他线程就不能运行，除非第一个线程自动放弃CPU。在一个单独的进程内部，没有时钟中断，所以不可能用轮转调度的方式调度线程。除非某个线程能够按照自己的意志进入运行时系统，否则调度程序就没有任何机会。<br>　　对线程永久运行问题的一个可能的解决方案是让运行时系统请求每秒一次的时钟信号（中断），但是这样对程序也是生硬和无序的。不可能总是高频率地发生周期性的时钟中断，即使可能，总的开销也是可观的。而且，线程可能也需要时钟中断，这就会扰乱运行时系统使用的时钟。</p>
<h2 id="在内核中实现线程">在内核中实现线程</h2><p>　　现在我们学习内核了解和管理线程的情形。如图2-16b所示，此时不在需要运行系统了。另外，每个进程中也没有线程表。相反，在内核中用来记录系统中所有线程的线程表。当某个线程希望创建一个新线程或撤销一个已有线程时，它进行一个系统调用，这个系统调用通过对线程表的更新完成线程创建或撤销工作。<br>　　内核的线程表保存了每个线程的寄存器、状态和其他信息。这些信息和在用户空间中（运行时系统中）的线程是一样的，但是现在保存在内核中。这些信息是传统内核所维护的每个单线程进程信息（即进程状态）的子集。另外，内核还维护了传统的进程表，以便跟踪进程的状态。<br>　　所有能够阻塞线程的调用都以系统调用的形式出现，这与运行时系统过程相比，代价是相当可观的。当一个线程阻塞时，内核根据其选择，可以运行同一个进程中的另一个线程（若有一个就绪线程）或者运行另一个进程中的线程。而在用户级线程中，运行时系统始终运行自己进程中的线程，知道内核暴多它的CPU（或者没有可运行的线程存在了）为止。<br>　　由于在内核中创建或撤销线程的代价比较大，某些系统采取“环保”的处理方式，回收其线程。当某个线程被撤销时，就把它标志位不可运行的，但是其内核数据结构没有收到影响。稍后，在必须创建一个新线程时，就重新启动某个旧线程，从而节省了某些开销。在用户级线程中线程回收也是可能的，但是由于其线程管理的代价小，所以没有必要。<br>　　内核线程不需要任何新的，非阻塞系统调用。另外，如果某个进程中的线程引起了页面故障，内核可以很方便地检查该进程是否有任何其他可运行的线程，如果有，在等待所需要的页面从磁盘读入时，就选择一个可运行的线程运行。这样做的主要缺点是系统调用的代价比较大，所以如果线程的操作（创建、终止等）比较多，就会带来很大的开销。<br>　　虽然使用内核线程可以解决许多问题，但是不会解决任何所有的问题。例如，当一个多线程进程创建新的进程时，会发生什么？新进程是拥有与原进程相同数量的线程，还是只有一个线程？在很多情况下，最好的选择是取决于进程计划下一步做什么。如果它要调用exec来启动一个新的程序，或许一个线程是正确的选择；如果它继续执行，则应该复制所有额线程。</p>
<h2 id="混合实现">混合实现</h2><p>　　一种方法是使用内核级线程，然后将用户级线程与某些或者全部内核线程多路复用起来，如图2-17所示。<br><img src="http://7vihec.com1.z0.glb.clouddn.com/os20141202-6.png" alt="图2-17"></p>
<p>　　采用这种方法，内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。如同在没有多线程能力操作系统中某个进程中的用户级线程一样，可以创建、撤销和调度这些用户级线程。在这种模型中，每个内核级线程有一个可以轮流使用的用户级线程集合。</p>
<h2 id="调度程序激活机制">调度程序激活机制</h2><p>　　尽管内核级线程在一些关键点上优于用户级线程，但无可争议的是内核级线程的速度慢。调度程序激活工作的目标是模拟内核线程的功能。<br>　　是该机制工作的基本思路是，当内核了解到一个线程被阻塞之后（例如，由于执行了一个阻塞系统调用或者产生了一个页面故障），讷河通知该进程的运行时系统，并且在堆栈中以参数形式传递有问题的线程编号和所发生事件的一个描述。内核通过在一个已知的起始地址启动运行系统，从而发出了通知，这是对UNIX中信号的一种粗略模拟。这个机制称为<code>上行调用</code>（upcall）。<br>　　调度程序激活机制的一个目标是作为上行调用的信赖基础，这是一种违反分层次系统内在结构的概念。通常，第n层提供第n+1层可调用的特殊服务，但是第n层不能调用第n+1层的过程。上行调用并不遵守这个基本原理。</p>
<h2 id="弹出式线程">弹出式线程</h2><p>　　一个消息的到达导致系统创建一个处理该消息的线程，这种线程称为<code>弹出式线程</code>，如图2-18所示。使用弹出式线程的结果是，消息到达与处理开始之间的时间非常短。<br><img src="http://7vihec.com1.z0.glb.clouddn.com/os20141202-7.png" alt="图2-18"></p>
<p>　　在使用太初式线程之前，需要提前进行计划。例如，哪个进程中的线程先运行？在内核空间中运行弹出式线程通常比在用户空间中容易且快捷，而且内核空间中的弹出式线程可以很容易访问所有的表格和I/O设备，这些也许在中断处理时有用。而另一方面，出错的内核线程比出错的用户线程造成更大的损害。</p>
<h2 id="使单线程代码多线程化">使单线程代码多线程化</h2><p>　　许多已有的程序是为单线程进程编写的。把这些程序改写成多线程需要比直接写多线程程序更高的技巧。</p>
<p>[参考资料]</p>
<ol>
<li><a href="">现代操作系统</a></li>
<li><a href="http://blog.csdn.net/peter_teng/article/details/9329329" target="_blank" rel="external">进程与线程</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[文章是Modern Operating System的读书笔记，这里是第二章进程与线程的读书笔记，本篇主要讲述了线程的一些知识，如使用线程的原因、经典的线程模型、POSIX线程以及线程的多重实现方式等...]]>
    
    </summary>
    
      <category term="OS" scheme="https://ningban.github.io/tags/OS/"/>
    
      <category term="Operating System" scheme="https://ningban.github.io/categories/Operating-System/"/>
    
  </entry>
  
</feed>